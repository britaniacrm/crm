{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = consumeActionMiddleware;\n\nvar _lodash = require('lodash');\n/**\n * Custom middleware that can consume the action before it can reach the reducer.\n *\n * This is useful when we want to optimistically update the local state,\n * but the same action will be dispatched again when it is fired from the offline queue.\n * To avoid updating the state again we change its type to one no reducer reacts to.\n *\n * For the action to be consumed it should have:\n * ```\n * consume: true\n * ```\n * property set.\n *\n * Note: For this to work correctly it should be placed as the last middleware in the chain.\n * For example, we do want the saga or logger to react to this action.\n */\n\n\nfunction consumeActionMiddleware() {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        var shouldConsumeAction = (0, _lodash.get)(action, 'consume', false);\n\n        if (shouldConsumeAction) {\n          return next({\n            type: '@@CONSUME@@',\n            payload: _extends({}, action)\n          });\n        }\n\n        return next(action);\n      };\n    };\n  };\n}","map":{"version":3,"sources":["/home/rafael/Documentos/britania/COM-front/node_modules/redux-offline-queue/lib/consumeActionMiddleware.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","consumeActionMiddleware","_lodash","require","store","next","action","shouldConsumeAction","get","type","payload"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIA,IAAIC,QAAQ,GAAGJ,MAAM,CAACK,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,SAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,UAAIV,MAAM,CAACY,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOL,MAAP;AAAgB,CAAhQ;;AAEAJ,OAAO,CAACa,OAAR,GAAkBC,uBAAlB;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,QAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,uBAAT,GAAmC;AACjC,SAAO,UAAUG,KAAV,EAAiB;AACtB,WAAO,UAAUC,IAAV,EAAgB;AACrB,aAAO,UAAUC,MAAV,EAAkB;AACvB,YAAIC,mBAAmB,GAAG,CAAC,GAAGL,OAAO,CAACM,GAAZ,EAAiBF,MAAjB,EAAyB,SAAzB,EAAoC,KAApC,CAA1B;;AACA,YAAIC,mBAAJ,EAAyB;AACvB,iBAAOF,IAAI,CAAC;AAAEI,YAAAA,IAAI,EAAE,aAAR;AAAuBC,YAAAA,OAAO,EAAErB,QAAQ,CAAC,EAAD,EAAKiB,MAAL;AAAxC,WAAD,CAAX;AACD;;AACD,eAAOD,IAAI,CAACC,MAAD,CAAX;AACD,OAND;AAOD,KARD;AASD,GAVD;AAWD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = consumeActionMiddleware;\n\nvar _lodash = require('lodash');\n\n/**\n * Custom middleware that can consume the action before it can reach the reducer.\n *\n * This is useful when we want to optimistically update the local state,\n * but the same action will be dispatched again when it is fired from the offline queue.\n * To avoid updating the state again we change its type to one no reducer reacts to.\n *\n * For the action to be consumed it should have:\n * ```\n * consume: true\n * ```\n * property set.\n *\n * Note: For this to work correctly it should be placed as the last middleware in the chain.\n * For example, we do want the saga or logger to react to this action.\n */\nfunction consumeActionMiddleware() {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        var shouldConsumeAction = (0, _lodash.get)(action, 'consume', false);\n        if (shouldConsumeAction) {\n          return next({ type: '@@CONSUME@@', payload: _extends({}, action) });\n        }\n        return next(action);\n      };\n    };\n  };\n}"]},"metadata":{},"sourceType":"script"}