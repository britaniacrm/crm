{"ast":null,"code":"'use strict';\n/**\n * Converter\n *\n * @param {string|Array} srcAlphabet\n * @param {string|Array} dstAlphabet\n * @constructor\n */\n\nfunction Converter(srcAlphabet, dstAlphabet) {\n  if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {\n    throw new Error('Bad alphabet');\n  }\n\n  this.srcAlphabet = srcAlphabet;\n  this.dstAlphabet = dstAlphabet;\n}\n/**\n * Convert number from source alphabet to destination alphabet\n *\n * @param {string|Array} number - number represented as a string or array of points\n *\n * @returns {string|Array}\n */\n\n\nConverter.prototype.convert = function (number) {\n  var i,\n      divide,\n      newlen,\n      numberMap = {},\n      fromBase = this.srcAlphabet.length,\n      toBase = this.dstAlphabet.length,\n      length = number.length,\n      result = typeof number === 'string' ? '' : [];\n\n  if (!this.isValid(number)) {\n    throw new Error('Number \"' + number + '\" contains of non-alphabetic digits (' + this.srcAlphabet + ')');\n  }\n\n  if (this.srcAlphabet === this.dstAlphabet) {\n    return number;\n  }\n\n  for (i = 0; i < length; i++) {\n    numberMap[i] = this.srcAlphabet.indexOf(number[i]);\n  }\n\n  do {\n    divide = 0;\n    newlen = 0;\n\n    for (i = 0; i < length; i++) {\n      divide = divide * fromBase + numberMap[i];\n\n      if (divide >= toBase) {\n        numberMap[newlen++] = parseInt(divide / toBase, 10);\n        divide = divide % toBase;\n      } else if (newlen > 0) {\n        numberMap[newlen++] = 0;\n      }\n    }\n\n    length = newlen;\n    result = this.dstAlphabet.slice(divide, divide + 1).concat(result);\n  } while (newlen !== 0);\n\n  return result;\n};\n/**\n * Valid number with source alphabet\n *\n * @param {number} number\n *\n * @returns {boolean}\n */\n\n\nConverter.prototype.isValid = function (number) {\n  var i = 0;\n\n  for (; i < number.length; ++i) {\n    if (this.srcAlphabet.indexOf(number[i]) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Converter;","map":{"version":3,"sources":["/home/rafael/Documentos/britania/COM-front/node_modules/any-base/src/converter.js"],"names":["Converter","srcAlphabet","dstAlphabet","length","Error","prototype","convert","number","i","divide","newlen","numberMap","fromBase","toBase","result","isValid","indexOf","parseInt","slice","concat","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Converter\n *\n * @param {string|Array} srcAlphabet\n * @param {string|Array} dstAlphabet\n * @constructor\n */\nfunction Converter(srcAlphabet, dstAlphabet) {\n    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {\n        throw new Error('Bad alphabet');\n    }\n    this.srcAlphabet = srcAlphabet;\n    this.dstAlphabet = dstAlphabet;\n}\n\n/**\n * Convert number from source alphabet to destination alphabet\n *\n * @param {string|Array} number - number represented as a string or array of points\n *\n * @returns {string|Array}\n */\nConverter.prototype.convert = function(number) {\n    var i, divide, newlen,\n    numberMap = {},\n    fromBase = this.srcAlphabet.length,\n    toBase = this.dstAlphabet.length,\n    length = number.length,\n    result = typeof number === 'string' ? '' : [];\n\n    if (!this.isValid(number)) {\n        throw new Error('Number \"' + number + '\" contains of non-alphabetic digits (' + this.srcAlphabet + ')');\n    }\n\n    if (this.srcAlphabet === this.dstAlphabet) {\n        return number;\n    }\n\n    for (i = 0; i < length; i++) {\n        numberMap[i] = this.srcAlphabet.indexOf(number[i]);\n    }\n    do {\n        divide = 0;\n        newlen = 0;\n        for (i = 0; i < length; i++) {\n            divide = divide * fromBase + numberMap[i];\n            if (divide >= toBase) {\n                numberMap[newlen++] = parseInt(divide / toBase, 10);\n                divide = divide % toBase;\n            } else if (newlen > 0) {\n                numberMap[newlen++] = 0;\n            }\n        }\n        length = newlen;\n        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);\n    } while (newlen !== 0);\n\n    return result;\n};\n\n/**\n * Valid number with source alphabet\n *\n * @param {number} number\n *\n * @returns {boolean}\n */\nConverter.prototype.isValid = function(number) {\n    var i = 0;\n    for (; i < number.length; ++i) {\n        if (this.srcAlphabet.indexOf(number[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n};\n\nmodule.exports = Converter;"]},"metadata":{},"sourceType":"script"}