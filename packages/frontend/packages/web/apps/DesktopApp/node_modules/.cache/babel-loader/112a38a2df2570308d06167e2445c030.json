{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = offlineMiddleware;\n\nvar _lodash = require('lodash');\n\nvar _v = require('uuid/v4');\n\nvar _v2 = _interopRequireDefault(_v);\n\nvar _initialState = require('./initialState');\n\nvar _initialState2 = _interopRequireDefault(_initialState);\n\nvar _actions = require('./actions');\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Helper method to dispatch the queued action again when the connection is available.\n *\n * It will modify the original action by adding:\n * ```\n * consume: true\n * ```\n * to skip firing the reducer\n * and:\n * ```\n * meta: {\n *   queueIfOffline: false\n * }\n * ```\n * to avoid putting it back to the queue.\n *\n * @param {Array} queue An array of queued Redux actions.\n * @param {Function} dispatch Redux's dispatch function.\n */\n\n\nfunction fireQueuedActions(queue, dispatch) {\n  queue.forEach(function (actionInQueue) {\n    dispatch(_extends({}, actionInQueue, {\n      consume: true,\n      meta: _extends({}, actionInQueue.meta, {\n        queueIfOffline: false\n      })\n    }));\n  });\n}\n/**\n * Custom Redux middleware for providing an offline queue functionality.\n *\n * Every action that should be queued if the device is offline should have:\n * ```\n * meta: {\n *   queueIfOffline: true\n * }\n * ```\n * property set.\n *\n * When the device is online this just passes the action to the next middleware as is.\n *\n * When the device is offline this action will be placed in an offline queue.\n * Those actions are later dispatched again when the device comes online.\n * Note that this action is still dispatched to make the optimistic updates possible.\n * However it wil have `skipSaga: true` property set\n * for the `suspendSaga` wrapper to skip the corresponding saga.\n *\n * Note that this queue is not persisted by itself.\n * One should provide a persistence config by using e.g.\n * `redux-persist` to keep the offline queue persisted.\n *\n * @param {Object} userConfig See: config.js for the configuration options.\n */\n\n\nfunction offlineMiddleware() {\n  var userConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        var config = (0, _config2.default)(userConfig);\n        var stateName = config.stateName,\n            additionalTriggers = config.additionalTriggers;\n        var state = (0, _lodash.get)(getState(), stateName, _initialState2.default);\n        var isConnected = state.isConnected;\n\n        if (action.type === _actions.ONLINE || (0, _lodash.includes)(additionalTriggers, action.type)) {\n          var result = next(action);\n\n          var _get2 = (0, _lodash.get)(getState(), stateName),\n              queue = _get2.queue;\n\n          var canFireQueue = isConnected || action.type === _actions.ONLINE;\n\n          if (canFireQueue) {\n            fireQueuedActions(queue, dispatch);\n            dispatch({\n              type: _actions.RESET_QUEUE\n            });\n          }\n\n          return result;\n        }\n\n        var shouldQueue = (0, _lodash.get)(action, ['meta', 'queueIfOffline'], false);\n\n        if (isConnected || !shouldQueue) {\n          return next(action);\n        }\n\n        var actionToQueue = {\n          type: _actions.QUEUE_ACTION,\n          payload: _extends({}, action, {\n            meta: _extends({\n              uuid: (0, _v2.default)()\n            }, action.meta)\n          })\n        };\n        dispatch(actionToQueue);\n\n        var skipSagaAction = _extends({}, action, {\n          skipSaga: true\n        });\n\n        return next(skipSagaAction);\n      };\n    };\n  };\n}","map":{"version":3,"sources":["/home/rafael/Documentos/britania/COM-front/node_modules/redux-offline-queue/lib/offlineMiddleware.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","offlineMiddleware","_lodash","require","_v","_v2","_interopRequireDefault","_initialState","_initialState2","_actions","_config","_config2","obj","__esModule","fireQueuedActions","queue","dispatch","forEach","actionInQueue","consume","meta","queueIfOffline","userConfig","undefined","_ref","getState","next","action","config","stateName","additionalTriggers","state","get","isConnected","type","ONLINE","includes","result","_get2","canFireQueue","RESET_QUEUE","shouldQueue","actionToQueue","QUEUE_ACTION","payload","uuid","skipSagaAction","skipSaga"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = offlineMiddleware;\n\nvar _lodash = require('lodash');\n\nvar _v = require('uuid/v4');\n\nvar _v2 = _interopRequireDefault(_v);\n\nvar _initialState = require('./initialState');\n\nvar _initialState2 = _interopRequireDefault(_initialState);\n\nvar _actions = require('./actions');\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Helper method to dispatch the queued action again when the connection is available.\n *\n * It will modify the original action by adding:\n * ```\n * consume: true\n * ```\n * to skip firing the reducer\n * and:\n * ```\n * meta: {\n *   queueIfOffline: false\n * }\n * ```\n * to avoid putting it back to the queue.\n *\n * @param {Array} queue An array of queued Redux actions.\n * @param {Function} dispatch Redux's dispatch function.\n */\nfunction fireQueuedActions(queue, dispatch) {\n  queue.forEach(function (actionInQueue) {\n    dispatch(_extends({}, actionInQueue, {\n      consume: true,\n      meta: _extends({}, actionInQueue.meta, {\n        queueIfOffline: false\n      })\n    }));\n  });\n}\n\n/**\n * Custom Redux middleware for providing an offline queue functionality.\n *\n * Every action that should be queued if the device is offline should have:\n * ```\n * meta: {\n *   queueIfOffline: true\n * }\n * ```\n * property set.\n *\n * When the device is online this just passes the action to the next middleware as is.\n *\n * When the device is offline this action will be placed in an offline queue.\n * Those actions are later dispatched again when the device comes online.\n * Note that this action is still dispatched to make the optimistic updates possible.\n * However it wil have `skipSaga: true` property set\n * for the `suspendSaga` wrapper to skip the corresponding saga.\n *\n * Note that this queue is not persisted by itself.\n * One should provide a persistence config by using e.g.\n * `redux-persist` to keep the offline queue persisted.\n *\n * @param {Object} userConfig See: config.js for the configuration options.\n */\nfunction offlineMiddleware() {\n  var userConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        var config = (0, _config2.default)(userConfig);\n        var stateName = config.stateName,\n            additionalTriggers = config.additionalTriggers;\n\n\n        var state = (0, _lodash.get)(getState(), stateName, _initialState2.default);\n\n        var isConnected = state.isConnected;\n\n\n        if (action.type === _actions.ONLINE || (0, _lodash.includes)(additionalTriggers, action.type)) {\n          var result = next(action);\n\n          var _get2 = (0, _lodash.get)(getState(), stateName),\n              queue = _get2.queue;\n\n          var canFireQueue = isConnected || action.type === _actions.ONLINE;\n          if (canFireQueue) {\n            fireQueuedActions(queue, dispatch);\n            dispatch({ type: _actions.RESET_QUEUE });\n          }\n          return result;\n        }\n\n        var shouldQueue = (0, _lodash.get)(action, ['meta', 'queueIfOffline'], false);\n\n        if (isConnected || !shouldQueue) {\n          return next(action);\n        }\n\n        var actionToQueue = {\n          type: _actions.QUEUE_ACTION,\n          payload: _extends({}, action, {\n            meta: _extends({\n              uuid: (0, _v2.default)()\n            }, action.meta)\n          })\n        };\n\n        dispatch(actionToQueue);\n\n        var skipSagaAction = _extends({}, action, {\n          skipSaga: true\n        });\n\n        return next(skipSagaAction);\n      };\n    };\n  };\n}"]},"metadata":{},"sourceType":"script"}