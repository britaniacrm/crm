{"ast":null,"code":"var _jsxFileName = \"/home/rafael/Documentos/britania/COM-front/packages/core/forms/src/providers/FieldProvider.js\";\nimport React, { useState, useEffect, useLayoutEffect, useRef, useCallback, useMemo, useImperativeHandle, forwardRef, useContext, memo } from 'react';\nimport { useField as useUnformField, FormContext as UnformContext } from '@unform/core';\nimport PropTypes from 'prop-types';\nimport uuid from 'short-uuid';\nimport * as Yup from 'yup';\nimport debounce from 'lodash/debounce';\nimport first from 'lodash/first';\nimport forEach from 'lodash/forEach';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport isEqual from 'lodash/isEqual';\nimport isFunction from 'lodash/isFunction';\nimport map from 'lodash/map';\nimport set from 'lodash/set';\nimport { FieldContext } from '../hooks/useField';\nimport useForm from '../hooks/useForm';\nimport validateDataBySchema from '../utils/validateDataBySchema';\nimport FieldComponent from './FieldComponent';\nconst FieldProvider = forwardRef((props, ref) => {\n  const {\n    name,\n    onChange: externalOnChange,\n    onBlur,\n    setMask: externalSetMask,\n    FieldComponent: ExternalFieldComponent,\n    registerFieldOptions: externalRegisterFieldOptions,\n    validateOnBlur,\n    defaultValue: externalDefaultValue,\n    touchOnChange,\n    ...otherProps\n  } = props;\n  const fieldRef = useRef(null);\n  const getMask = useCallback((val = '') => {\n    if (externalSetMask) {\n      const newMask = externalSetMask(val, otherProps);\n\n      if (!isEmpty(newMask)) {\n        return newMask;\n      }\n    }\n\n    return undefined;\n  }, [externalSetMask, otherProps]);\n  const [mounted, setMounted] = useState(false);\n  const [touched, setTouched] = useState(false);\n  const [mask, setMask] = useState(getMask());\n  const [customError, setCustomError] = useState(null);\n  const {\n    unregisterField\n  } = useContext(UnformContext);\n  const {\n    formRef,\n    schema,\n    needSchema,\n    getFieldZIndex,\n    getFieldOrder,\n    registerFieldName,\n    unregisterFieldName,\n    defaultValues\n  } = useForm();\n  const order = useMemo(() => getFieldOrder(), [getFieldOrder]);\n  const zIndex = useMemo(() => getFieldZIndex(), [getFieldZIndex]);\n  const {\n    fieldName,\n    registerField,\n    defaultValue: unformDefaultValue,\n    error,\n    clearError\n  } = useUnformField(name);\n  const id = useMemo(() => `${fieldName}-${uuid().new()}`, [fieldName]);\n  const defaultValue = useMemo(() => {\n    if (unformDefaultValue) {\n      return unformDefaultValue;\n    }\n\n    const defaultValueByForm = get(defaultValues, fieldName);\n\n    if (defaultValueByForm !== undefined) {\n      return defaultValueByForm;\n    }\n\n    return externalDefaultValue;\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  const registerFieldOptions = useMemo(() => isFunction(externalRegisterFieldOptions) ? externalRegisterFieldOptions(fieldRef) : externalRegisterFieldOptions, [externalRegisterFieldOptions]);\n  const fieldSchema = useMemo(() => {\n    try {\n      if (needSchema) {\n        return Yup.reach(schema, fieldName);\n      } // form without schema constructor\n\n\n      return null;\n    } catch (err) {\n      // field view not found on schema\n      return null;\n    }\n  }, [fieldName, schema, needSchema]);\n  const required = useMemo(() => {\n    var _fieldSchema$exclusiv;\n\n    return (fieldSchema === null || fieldSchema === void 0 ? void 0 : (_fieldSchema$exclusiv = fieldSchema.exclusiveTests) === null || _fieldSchema$exclusiv === void 0 ? void 0 : _fieldSchema$exclusiv.required) || false;\n  }, [fieldSchema]);\n  const setError = useCallback(err => {\n    var _formRef$current;\n\n    if (formRef === null || formRef === void 0 ? void 0 : (_formRef$current = formRef.current) === null || _formRef$current === void 0 ? void 0 : _formRef$current.setFieldError) {\n      // TODO: setar erro por campo no unform não é performatico em formulários grandes\n      // ISSUE: https://github.com/unform/unform/issues/308\n      formRef.current.setFieldError(fieldName, err);\n    }\n  }, [fieldName, formRef]);\n  const doValidateField = useCallback(debounce(async (value, resolve) => {\n    try {\n      if (formRef === null || formRef === void 0 ? void 0 : formRef.current) {\n        var _formRef$current3;\n\n        const formData = formRef.current.getData() || {};\n\n        if (value === undefined) {\n          var _formRef$current2;\n\n          value = (formRef === null || formRef === void 0 ? void 0 : (_formRef$current2 = formRef.current) === null || _formRef$current2 === void 0 ? void 0 : _formRef$current2.getFieldValue(fieldName)) || '';\n        }\n\n        const oldError = formRef === null || formRef === void 0 ? void 0 : (_formRef$current3 = formRef.current) === null || _formRef$current3 === void 0 ? void 0 : _formRef$current3.getFieldError(fieldName);\n        await validateDataBySchema({\n          data: { ...formData,\n            [fieldName]: value\n          },\n          schema: Yup.object().shape({\n            [fieldName]: fieldSchema\n          })\n        });\n\n        if (oldError) {\n          setError(null);\n        }\n\n        if (customError) {\n          throw new Error(customError);\n        }\n\n        resolve();\n      }\n    } catch (err) {\n      if (err.formError) {\n        const objErrors = {};\n        forEach(err.messages, (message, name) => {\n          set(objErrors, name, message);\n        });\n        const formError = first(map(objErrors));\n        setError(formError);\n        resolve(formError);\n      } else {\n        setError(err.message);\n        resolve(err.message);\n      }\n    }\n  }, 500), [customError, fieldName, fieldSchema, formRef, setError]);\n  const validateField = useCallback(value => new Promise(resolve => {\n    doValidateField(value, resolve);\n  }), [doValidateField]);\n  const handleChange = useCallback(async event => {\n    if (externalSetMask) {\n      setMask(getMask(event.target[registerFieldOptions.path]));\n    }\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [externalSetMask, registerFieldOptions.path]);\n  const handleBlur = useCallback(event => {\n    var _formRef$current4;\n\n    onBlur(event);\n\n    if (formRef === null || formRef === void 0 ? void 0 : (_formRef$current4 = formRef.current) === null || _formRef$current4 === void 0 ? void 0 : _formRef$current4.getFieldValue) {\n      validateField();\n    }\n\n    if (!touched) {\n      setTouched(true);\n    }\n  }, [formRef, onBlur, touched, validateField]);\n  const handleChangeNative = useCallback((value, ...other) => {\n    if (fieldRef.current) {\n      const currentFieldValue = formRef === null || formRef === void 0 ? void 0 : formRef.current.getFieldValue(fieldName);\n\n      if (!isEqual(currentFieldValue, value)) {\n        formRef.current.setFieldValue(fieldName, value, ...other);\n        fieldRef.current[registerFieldOptions.path] = value;\n        handleChange({\n          target: {\n            [registerFieldOptions.path]: value\n          }\n        });\n      } else {\n        externalOnChange({\n          target: {\n            [registerFieldOptions.path]: value\n          }\n        }, ...other);\n\n        if (touchOnChange) {\n          validateField(value);\n        }\n      }\n    }\n  }, [formRef, fieldName, registerFieldOptions.path, handleChange, externalOnChange, touchOnChange, validateField]);\n  const handleBlurNative = useCallback(() => {\n    if (fieldRef.current) {\n      const value = formRef === null || formRef === void 0 ? void 0 : formRef.current.getFieldValue(fieldName);\n      handleBlur({\n        target: {\n          value\n        }\n      });\n    }\n  }, [fieldName, formRef, handleBlur]);\n  const resetField = useCallback(() => {\n    // reset errors\n    setTouched(false);\n    formRef.current.clearField(fieldName);\n    formRef.current.setFieldError(fieldName, null);\n    setCustomError();\n  }, [fieldName, formRef]); // register unform field\n\n  useEffect(() => {\n    if (fieldSchema) {\n      registerField({\n        name: fieldName,\n        ref: fieldRef.current,\n        ...registerFieldOptions\n      });\n      registerFieldName(fieldName);\n    }\n\n    return () => {\n      unregisterField(fieldName);\n      unregisterFieldName(fieldName);\n    }; // eslint-disable-next-line\n  }, [fieldSchema, fieldName, registerField, registerFieldName, // registerFieldOptions,\n  unregisterFieldName, unregisterField, touched]);\n  useEffect(() => {\n    if (error) {\n      setTouched(true);\n    }\n  }, [error]); // clear field when touched return to false (reset)\n\n  useEffect(() => {\n    var _formRef$current5, _fieldRef$current;\n\n    const fieldValue = formRef === null || formRef === void 0 ? void 0 : (_formRef$current5 = formRef.current) === null || _formRef$current5 === void 0 ? void 0 : _formRef$current5.getFieldValue(fieldName);\n\n    if (!touched && fieldValue !== undefined && fieldValue !== (fieldRef === null || fieldRef === void 0 ? void 0 : (_fieldRef$current = fieldRef.current) === null || _fieldRef$current === void 0 ? void 0 : _fieldRef$current.defaultValue)) {\n      formRef.current.clearField(fieldName);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [touched, customError]); // set mask on second render\n  // because controlled fields set the default value - if it exists - on first render (didMount)\n\n  useLayoutEffect(() => {\n    if (externalSetMask) {\n      var _fieldRef$current2, _fieldRef$current3;\n\n      const value = mounted ? fieldRef === null || fieldRef === void 0 ? void 0 : (_fieldRef$current2 = fieldRef.current) === null || _fieldRef$current2 === void 0 ? void 0 : _fieldRef$current2[registerFieldOptions.path] : fieldRef === null || fieldRef === void 0 ? void 0 : (_fieldRef$current3 = fieldRef.current) === null || _fieldRef$current3 === void 0 ? void 0 : _fieldRef$current3.defaultValue;\n      setMask(getMask(value));\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [externalSetMask, fieldRef, registerFieldOptions.path]);\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n  const imperativeHandles = useMemo(() => ({\n    name,\n    defaultValue,\n    resetField,\n    externalOnChange,\n    validateField,\n    setTouched,\n    customError,\n    setCustomError,\n    touched,\n    setError,\n    error\n  }), [name, defaultValue, resetField, externalOnChange, validateField, customError, touched, setError, error]);\n  useImperativeHandle(ref, () => fieldRef === null || fieldRef === void 0 ? void 0 : fieldRef.current, [fieldRef]);\n  const state = useMemo(() => ({\n    id,\n    imperativeHandles,\n    fieldName,\n    defaultValue,\n    mask,\n    error,\n    clearError,\n    fieldRef,\n    handleChange,\n    handleBlur,\n    handleChangeNative,\n    handleBlurNative,\n    required,\n    formRef,\n    touched,\n    setTouched,\n    resetField,\n    externalOnChange,\n    validateField,\n    zIndex\n  }), [id, imperativeHandles, fieldName, defaultValue, mask, error, clearError, handleChange, handleBlur, handleChangeNative, handleBlurNative, required, formRef, touched, resetField, externalOnChange, validateField, zIndex]);\n  return /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: state,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 385,\n      columnNumber: 5\n    }\n  }, (!isEmpty(fieldSchema) || !needSchema) && /*#__PURE__*/React.createElement(FieldComponent, Object.assign({\n    ref: fieldRef\n  }, otherProps, {\n    Component: ExternalFieldComponent,\n    id: id,\n    name: name,\n    defaultValue: defaultValue,\n    order: order,\n    touchOnChange: touchOnChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 387,\n      columnNumber: 9\n    }\n  })));\n});\nFieldProvider.propTypes = {\n  /** this name will be used to register the field into form context */\n  name: PropTypes.string.isRequired,\n\n  /** it is the Field to be render with TextField */\n  FieldComponent: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired,\n\n  /** object with the Unform registerField options */\n  registerFieldOptions: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n\n  /** function that run when the input changes */\n  onChange: PropTypes.func,\n\n  /** function that run when the input blur */\n  onBlur: PropTypes.func,\n\n  /**\n   * function that receive input data and configs, and return the mask to input.\n   * If it is `undefined`, the input doesn't be masked\n   */\n  setMask: PropTypes.func,\n  validateOnBlur: PropTypes.bool,\n  defaultValue: PropTypes.any,\n  transformValue: PropTypes.func,\n  transformRender: PropTypes.func,\n  onValueChange: PropTypes.func,\n  touchOnChange: PropTypes.bool\n};\nFieldProvider.defaultProps = {\n  registerFieldOptions: {\n    path: '/'\n  },\n\n  onChange() {},\n\n  onBlur() {},\n\n  setMask: undefined,\n  validateOnBlur: true,\n  defaultValue: undefined,\n  transformValue: v => v,\n  transformRender: v => v,\n\n  onValueChange() {},\n\n  touchOnChange: false\n};\nexport default memo(FieldProvider);","map":{"version":3,"sources":["/home/rafael/Documentos/britania/COM-front/packages/core/forms/src/providers/FieldProvider.js"],"names":["React","useState","useEffect","useLayoutEffect","useRef","useCallback","useMemo","useImperativeHandle","forwardRef","useContext","memo","useField","useUnformField","FormContext","UnformContext","PropTypes","uuid","Yup","debounce","first","forEach","get","isEmpty","isEqual","isFunction","map","set","FieldContext","useForm","validateDataBySchema","FieldComponent","FieldProvider","props","ref","name","onChange","externalOnChange","onBlur","setMask","externalSetMask","ExternalFieldComponent","registerFieldOptions","externalRegisterFieldOptions","validateOnBlur","defaultValue","externalDefaultValue","touchOnChange","otherProps","fieldRef","getMask","val","newMask","undefined","mounted","setMounted","touched","setTouched","mask","customError","setCustomError","unregisterField","formRef","schema","needSchema","getFieldZIndex","getFieldOrder","registerFieldName","unregisterFieldName","defaultValues","order","zIndex","fieldName","registerField","unformDefaultValue","error","clearError","id","new","defaultValueByForm","fieldSchema","reach","err","required","exclusiveTests","setError","current","setFieldError","doValidateField","value","resolve","formData","getData","getFieldValue","oldError","getFieldError","data","object","shape","Error","formError","objErrors","messages","message","validateField","Promise","handleChange","event","target","path","handleBlur","handleChangeNative","other","currentFieldValue","setFieldValue","handleBlurNative","resetField","clearField","fieldValue","imperativeHandles","state","propTypes","string","isRequired","oneOfType","func","bool","any","transformValue","transformRender","onValueChange","defaultProps","v"],"mappings":"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","sourcesContent":["import React, {\n  useState,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useCallback,\n  useMemo,\n  useImperativeHandle,\n  forwardRef,\n  useContext,\n  memo\n} from 'react'\n\nimport {\n  useField as useUnformField,\n  FormContext as UnformContext\n} from '@unform/core'\nimport PropTypes from 'prop-types'\nimport uuid from 'short-uuid'\nimport * as Yup from 'yup'\n\nimport debounce from 'lodash/debounce'\nimport first from 'lodash/first'\nimport forEach from 'lodash/forEach'\nimport get from 'lodash/get'\nimport isEmpty from 'lodash/isEmpty'\nimport isEqual from 'lodash/isEqual'\nimport isFunction from 'lodash/isFunction'\nimport map from 'lodash/map'\nimport set from 'lodash/set'\n\nimport { FieldContext } from '../hooks/useField'\nimport useForm from '../hooks/useForm'\nimport validateDataBySchema from '../utils/validateDataBySchema'\nimport FieldComponent from './FieldComponent'\n\nconst FieldProvider = forwardRef((props, ref) => {\n  const {\n    name,\n    onChange: externalOnChange,\n    onBlur,\n    setMask: externalSetMask,\n    FieldComponent: ExternalFieldComponent,\n    registerFieldOptions: externalRegisterFieldOptions,\n    validateOnBlur,\n    defaultValue: externalDefaultValue,\n    touchOnChange,\n    ...otherProps\n  } = props\n\n  const fieldRef = useRef(null)\n\n  const getMask = useCallback(\n    (val = '') => {\n      if (externalSetMask) {\n        const newMask = externalSetMask(val, otherProps)\n        if (!isEmpty(newMask)) {\n          return newMask\n        }\n      }\n      return undefined\n    },\n    [externalSetMask, otherProps]\n  )\n\n  const [mounted, setMounted] = useState(false)\n  const [touched, setTouched] = useState(false)\n  const [mask, setMask] = useState(getMask())\n  const [customError, setCustomError] = useState(null)\n\n  const { unregisterField } = useContext(UnformContext)\n\n  const {\n    formRef,\n    schema,\n    needSchema,\n    getFieldZIndex,\n    getFieldOrder,\n    registerFieldName,\n    unregisterFieldName,\n    defaultValues\n  } = useForm()\n\n  const order = useMemo(() => getFieldOrder(), [getFieldOrder])\n  const zIndex = useMemo(() => getFieldZIndex(), [getFieldZIndex])\n\n  const {\n    fieldName,\n    registerField,\n    defaultValue: unformDefaultValue,\n    error,\n    clearError\n  } = useUnformField(name)\n\n  const id = useMemo(\n    () => `${ fieldName }-${ uuid().new() }`,\n    [fieldName]\n  )\n\n  const defaultValue = useMemo(\n    () => {\n      if (unformDefaultValue) {\n        return unformDefaultValue\n      }\n      const defaultValueByForm = get(defaultValues, fieldName)\n      if (defaultValueByForm !== undefined) {\n        return defaultValueByForm\n      }\n      return externalDefaultValue\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  )\n\n  const registerFieldOptions = useMemo(\n    () => (\n      isFunction(externalRegisterFieldOptions)\n        ? externalRegisterFieldOptions(fieldRef)\n        : externalRegisterFieldOptions\n    ),\n    [externalRegisterFieldOptions]\n  )\n\n  const fieldSchema = useMemo(\n    () => {\n      try {\n        if (needSchema) {\n          return Yup.reach(schema, fieldName)\n        }\n        // form without schema constructor\n        return null\n      } catch (err) {\n        // field view not found on schema\n        return null\n      }\n    },\n    [fieldName, schema, needSchema]\n  )\n\n  const required = useMemo(\n    () => fieldSchema?.exclusiveTests?.required || false,\n    [fieldSchema]\n  )\n\n  const setError = useCallback(\n    (err) => {\n      if (formRef?.current?.setFieldError) {\n        // TODO: setar erro por campo no unform não é performatico em formulários grandes\n        // ISSUE: https://github.com/unform/unform/issues/308\n        formRef.current.setFieldError(fieldName, err)\n      }\n    },\n    [fieldName, formRef]\n  )\n\n  const doValidateField = useCallback(\n    debounce(\n      async (value, resolve) => {\n        try {\n          if (formRef?.current) {\n            const formData = formRef.current.getData() || {}\n            if (value === undefined) {\n              value = formRef?.current?.getFieldValue(fieldName) || ''\n            }\n\n            const oldError = formRef?.current?.getFieldError(fieldName)\n\n            await validateDataBySchema({\n              data: {\n                ...formData,\n                [fieldName]: value\n              },\n              schema: Yup.object().shape({ [fieldName]: fieldSchema })\n            })\n            if (oldError) {\n              setError(null)\n            }\n            if (customError) {\n              throw new Error(customError)\n            }\n            resolve()\n          }\n        } catch (err) {\n          if (err.formError) {\n            const objErrors = {}\n            forEach(err.messages, (message, name) => {\n              set(objErrors, name, message)\n            })\n            const formError = first(map(objErrors))\n            setError(formError)\n            resolve(formError)\n          } else {\n            setError(err.message)\n            resolve(err.message)\n          }\n        }\n      },\n      500\n    ),\n    [customError, fieldName, fieldSchema, formRef, setError]\n  )\n\n  const validateField = useCallback(\n    (value) => new Promise((resolve) => {\n      doValidateField(value, resolve)\n    }),\n    [doValidateField]\n  )\n\n  const handleChange = useCallback(\n    async (event) => {\n      if (externalSetMask) {\n        setMask(getMask(event.target[registerFieldOptions.path]))\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      externalSetMask,\n      registerFieldOptions.path\n    ]\n  )\n\n  const handleBlur = useCallback(\n    (event) => {\n      onBlur(event)\n      if (formRef?.current?.getFieldValue) {\n        validateField()\n      }\n      if (!touched) {\n        setTouched(true)\n      }\n    },\n    [formRef, onBlur, touched, validateField]\n  )\n\n  const handleChangeNative = useCallback(\n    (value, ...other) => {\n      if (fieldRef.current) {\n        const currentFieldValue = formRef?.current.getFieldValue(fieldName)\n        if (!isEqual(currentFieldValue, value)) {\n          formRef.current.setFieldValue(fieldName, value, ...other)\n          fieldRef.current[registerFieldOptions.path] = value\n          handleChange({ target: { [registerFieldOptions.path]: value } })\n        } else {\n          externalOnChange({ target: { [registerFieldOptions.path]: value } }, ...other)\n\n          if (touchOnChange) {\n            validateField(value)\n          }\n        }\n      }\n    },\n    [formRef, fieldName, registerFieldOptions.path, handleChange, externalOnChange, touchOnChange, validateField]\n  )\n\n  const handleBlurNative = useCallback(\n    () => {\n      if (fieldRef.current) {\n        const value = formRef?.current.getFieldValue(fieldName)\n        handleBlur({ target: { value } })\n      }\n    },\n    [fieldName, formRef, handleBlur]\n  )\n\n  const resetField = useCallback(\n    () => {\n      // reset errors\n      setTouched(false)\n      formRef.current.clearField(fieldName)\n      formRef.current.setFieldError(fieldName, null)\n      setCustomError()\n    },\n    [fieldName, formRef]\n  )\n\n  // register unform field\n  useEffect(() => {\n    if (fieldSchema) {\n      registerField({\n        name: fieldName,\n        ref: fieldRef.current,\n        ...registerFieldOptions\n      })\n      registerFieldName(fieldName)\n    }\n    return () => {\n      unregisterField(fieldName)\n      unregisterFieldName(fieldName)\n    }\n    // eslint-disable-next-line\n  }, [\n    fieldSchema,\n    fieldName,\n    registerField,\n    registerFieldName,\n    // registerFieldOptions,\n    unregisterFieldName,\n    unregisterField,\n    touched\n  ])\n\n  useEffect(() => {\n    if (error) {\n      setTouched(true)\n    }\n  }, [error])\n\n  // clear field when touched return to false (reset)\n  useEffect(() => {\n    const fieldValue = formRef?.current?.getFieldValue(fieldName)\n    if (\n      !touched &&\n      fieldValue !== undefined &&\n      fieldValue !== fieldRef?.current?.defaultValue\n    ) {\n      formRef.current.clearField(fieldName)\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [touched, customError])\n\n  // set mask on second render\n  // because controlled fields set the default value - if it exists - on first render (didMount)\n  useLayoutEffect(() => {\n    if (externalSetMask) {\n      const value = mounted\n        ? fieldRef?.current?.[registerFieldOptions.path]\n        : fieldRef?.current?.defaultValue\n\n      setMask(getMask(value))\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [externalSetMask, fieldRef, registerFieldOptions.path])\n\n  useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  const imperativeHandles = useMemo(\n    () => ({\n      name,\n      defaultValue,\n      resetField,\n      externalOnChange,\n      validateField,\n      setTouched,\n      customError,\n      setCustomError,\n      touched,\n      setError,\n      error\n    }),\n    [name, defaultValue, resetField, externalOnChange, validateField, customError, touched, setError, error]\n  )\n\n  useImperativeHandle(ref, () => fieldRef?.current, [fieldRef])\n\n  const state = useMemo(\n    () => ({\n      id,\n      imperativeHandles,\n      fieldName,\n      defaultValue,\n      mask,\n      error,\n      clearError,\n      fieldRef,\n      handleChange,\n      handleBlur,\n      handleChangeNative,\n      handleBlurNative,\n      required,\n      formRef,\n      touched,\n      setTouched,\n      resetField,\n      externalOnChange,\n      validateField,\n      zIndex\n    }),\n    [id, imperativeHandles, fieldName, defaultValue, mask, error, clearError, handleChange, handleBlur, handleChangeNative, handleBlurNative, required, formRef, touched, resetField, externalOnChange, validateField, zIndex]\n  )\n\n  return (\n    <FieldContext.Provider value={ state }>\n      {(!isEmpty(fieldSchema) || !needSchema) && (\n        <FieldComponent\n          ref={ fieldRef }\n          { ...otherProps }\n          Component={ ExternalFieldComponent }\n          id={ id }\n          name={ name }\n          defaultValue={ defaultValue }\n          order={ order }\n          touchOnChange={ touchOnChange }\n        />\n      )}\n    </FieldContext.Provider>\n  )\n})\n\nFieldProvider.propTypes = {\n  /** this name will be used to register the field into form context */\n  name: PropTypes.string.isRequired,\n  /** it is the Field to be render with TextField */\n  FieldComponent: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.func\n  ]).isRequired,\n  /** object with the Unform registerField options */\n  registerFieldOptions: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.func\n  ]),\n  /** function that run when the input changes */\n  onChange: PropTypes.func,\n  /** function that run when the input blur */\n  onBlur: PropTypes.func,\n  /**\n   * function that receive input data and configs, and return the mask to input.\n   * If it is `undefined`, the input doesn't be masked\n   */\n  setMask: PropTypes.func,\n  validateOnBlur: PropTypes.bool,\n  defaultValue: PropTypes.any,\n  transformValue: PropTypes.func,\n  transformRender: PropTypes.func,\n  onValueChange: PropTypes.func,\n  touchOnChange: PropTypes.bool\n}\n\nFieldProvider.defaultProps = {\n  registerFieldOptions: { path: '/' },\n  onChange () {},\n  onBlur () {},\n  setMask: undefined,\n  validateOnBlur: true,\n  defaultValue: undefined,\n  transformValue: (v) => v,\n  transformRender: (v) => v,\n  onValueChange () {},\n  touchOnChange: false\n}\n\nexport default memo(FieldProvider)\n"]},"metadata":{},"sourceType":"module"}