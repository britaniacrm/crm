{"ast":null,"code":"import withScrolling, { createScrollingComponent, createVerticalStrength, createHorizontalStrength } from 'frontend-collective-react-dnd-scrollzone';\nimport isEqual from 'lodash.isequal';\nimport PropTypes from 'prop-types';\nimport React, { Component, Children, cloneElement } from 'react';\nimport { DragSource, DropTarget, DndContext, DndProvider } from 'react-dnd';\nimport { HTML5Backend } from 'react-dnd-html5-backend';\nimport { List, AutoSizer } from 'react-virtualized';\nimport { findDOMNode } from 'react-dom';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  } // Binding \"this\" is important for shallow renderer support.\n\n\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n} // React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\n\n\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component) {\n  var prototype = Component.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {\n    return Component;\n  } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n\n\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n\n  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n    var componentName = Component.displayName || Component.name;\n    var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') + '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks');\n  } // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n\n\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  } // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n\n\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component;\n}\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\n\n\nfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n  var targetIndex = _ref.targetIndex,\n      node = _ref.node,\n      currentIndex = _ref.currentIndex,\n      getNodeKey = _ref.getNodeKey,\n      _ref$path = _ref.path,\n      path = _ref$path === void 0 ? [] : _ref$path,\n      _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n      lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,\n      _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n      ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,\n      _ref$isPseudoRoot = _ref.isPseudoRoot,\n      isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot; // The pseudo-root is not considered in the path\n\n  var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]) : []; // Return target node when found\n\n  if (currentIndex === targetIndex) {\n    return {\n      node: node,\n      lowerSiblingCounts: lowerSiblingCounts,\n      path: selfPath\n    };\n  } // Add one and continue for nodes with no children or hidden children\n\n\n  if (!node.children || ignoreCollapsed && node.expanded !== true) {\n    return {\n      nextIndex: currentIndex + 1\n    };\n  } // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n\n\n  var childIndex = currentIndex + 1;\n  var childCount = node.children.length;\n\n  for (var i = 0; i < childCount; i += 1) {\n    var result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed: ignoreCollapsed,\n      getNodeKey: getNodeKey,\n      targetIndex: targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  } // If the target node is not found, return the farthest traversed index\n\n\n  return {\n    nextIndex: childIndex\n  };\n}\n\nfunction getDescendantCount(_ref2) {\n  var node = _ref2.node,\n      _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n      ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;\n  return getNodeDataAtTreeIndexOrNextIndex({\n    getNodeKey: function getNodeKey() {},\n    ignoreCollapsed: ignoreCollapsed,\n    node: node,\n    currentIndex: 0,\n    targetIndex: -1\n  }).nextIndex - 1;\n}\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction walkDescendants(_ref3) {\n  var callback = _ref3.callback,\n      getNodeKey = _ref3.getNodeKey,\n      ignoreCollapsed = _ref3.ignoreCollapsed,\n      _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n      isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,\n      node = _ref3.node,\n      _ref3$parentNode = _ref3.parentNode,\n      parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,\n      currentIndex = _ref3.currentIndex,\n      _ref3$path = _ref3.path,\n      path = _ref3$path === void 0 ? [] : _ref3$path,\n      _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n      lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou; // The pseudo-root is not considered in the path\n\n  var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = isPseudoRoot ? null : {\n    node: node,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  if (!isPseudoRoot) {\n    var callbackResult = callback(selfInfo); // Cut walk short if the callback returned false\n\n    if (callbackResult === false) {\n      return false;\n    }\n  } // Return self on nodes with no children or hidden children\n\n\n  if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return currentIndex;\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = node.children.length;\n\n  if (typeof node.children !== 'function') {\n    for (var i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n        path: selfPath\n      }); // Cut walk short if the callback returned false\n\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction mapDescendants(_ref4) {\n  var callback = _ref4.callback,\n      getNodeKey = _ref4.getNodeKey,\n      ignoreCollapsed = _ref4.ignoreCollapsed,\n      _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n      isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,\n      node = _ref4.node,\n      _ref4$parentNode = _ref4.parentNode,\n      parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,\n      currentIndex = _ref4.currentIndex,\n      _ref4$path = _ref4.path,\n      path = _ref4$path === void 0 ? [] : _ref4$path,\n      _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n      lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;\n\n  var nextNode = _objectSpread2({}, node); // The pseudo-root is not considered in the path\n\n\n  var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n    node: nextNode,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = {\n    node: nextNode,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  }; // Return self on nodes with no children or hidden children\n\n  if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = nextNode.children.length;\n\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map(function (child, i) {\n      var mapResult = mapDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\n\n\nfunction getVisibleNodeCount(_ref5) {\n  var treeData = _ref5.treeData;\n\n  var traverse = function traverse(node) {\n    if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n      return 1;\n    }\n\n    return 1 + node.children.reduce(function (total, currentNode) {\n      return total + traverse(currentNode);\n    }, 0);\n  };\n\n  return treeData.reduce(function (total, currentNode) {\n    return total + traverse(currentNode);\n  }, 0);\n}\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\n\n\nfunction getVisibleNodeInfoAtIndex(_ref6) {\n  var treeData = _ref6.treeData,\n      targetIndex = _ref6.index,\n      getNodeKey = _ref6.getNodeKey;\n\n  if (!treeData || treeData.length < 1) {\n    return null;\n  } // Call the tree traversal with a pseudo-root node\n\n\n  var result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex: targetIndex,\n    getNodeKey: getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\n\n\nfunction walk(_ref7) {\n  var treeData = _ref7.treeData,\n      getNodeKey = _ref7.getNodeKey,\n      callback = _ref7.callback,\n      _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n      ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction map(_ref8) {\n  var treeData = _ref8.treeData,\n      getNodeKey = _ref8.getNodeKey,\n      callback = _ref8.callback,\n      _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n      ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction toggleExpandedForAll(_ref9) {\n  var treeData = _ref9.treeData,\n      _ref9$expanded = _ref9.expanded,\n      expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;\n  return map({\n    treeData: treeData,\n    callback: function callback(_ref10) {\n      var node = _ref10.node;\n      return _objectSpread2(_objectSpread2({}, node), {}, {\n        expanded: expanded\n      });\n    },\n    getNodeKey: function getNodeKey(_ref11) {\n      var treeIndex = _ref11.treeIndex;\n      return treeIndex;\n    },\n    ignoreCollapsed: false\n  });\n}\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction changeNodeAtPath(_ref12) {\n  var treeData = _ref12.treeData,\n      path = _ref12.path,\n      newNode = _ref12.newNode,\n      getNodeKey = _ref12.getNodeKey,\n      _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n      ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;\n  var RESULT_MISS = 'RESULT_MISS';\n\n  var traverse = function traverse(_ref13) {\n    var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n        isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,\n        node = _ref13.node,\n        currentTreeIndex = _ref13.currentTreeIndex,\n        pathIndex = _ref13.pathIndex;\n\n    if (!isPseudoRoot && getNodeKey({\n      node: node,\n      treeIndex: currentTreeIndex\n    }) !== path[pathIndex]) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function' ? newNode({\n        node: node,\n        treeIndex: currentTreeIndex\n      }) : newNode;\n    }\n\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.');\n    }\n\n    var nextTreeIndex = currentTreeIndex + 1;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      var _result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      }); // If the result went down the correct path\n\n\n      if (_result !== RESULT_MISS) {\n        if (_result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return _objectSpread2(_objectSpread2({}, node), {}, {\n            children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))\n          });\n        } // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n\n\n        return _objectSpread2(_objectSpread2({}, node), {}, {\n          children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))\n        });\n      }\n\n      nextTreeIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    }\n\n    return RESULT_MISS;\n  }; // Use a pseudo-root node in the beginning traversal\n\n\n  var result = traverse({\n    node: {\n      children: treeData\n    },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.');\n  }\n\n  return result.children;\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\n\n\nfunction removeNodeAtPath(_ref14) {\n  var treeData = _ref14.treeData,\n      path = _ref14.path,\n      getNodeKey = _ref14.getNodeKey,\n      _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n      ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;\n  return changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: null // Delete the node\n\n  });\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\n\n\nfunction removeNode(_ref15) {\n  var treeData = _ref15.treeData,\n      path = _ref15.path,\n      getNodeKey = _ref15.getNodeKey,\n      _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n      ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;\n  var removedNode = null;\n  var removedTreeIndex = null;\n  var nextTreeData = changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: function newNode(_ref16) {\n      var node = _ref16.node,\n          treeIndex = _ref16.treeIndex; // Store the target node and delete it from the tree\n\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n      return null;\n    }\n  });\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\n\n\nfunction getNodeAtPath(_ref17) {\n  var treeData = _ref17.treeData,\n      path = _ref17.path,\n      getNodeKey = _ref17.getNodeKey,\n      _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n      ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;\n  var foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData: treeData,\n      path: path,\n      getNodeKey: getNodeKey,\n      ignoreCollapsed: ignoreCollapsed,\n      newNode: function newNode(_ref18) {\n        var node = _ref18.node,\n            treeIndex = _ref18.treeIndex;\n        foundNodeInfo = {\n          node: node,\n          treeIndex: treeIndex\n        };\n        return node;\n      }\n    });\n  } catch (err) {// Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\n\n\nfunction addNodeUnderParent(_ref19) {\n  var treeData = _ref19.treeData,\n      newNode = _ref19.newNode,\n      _ref19$parentKey = _ref19.parentKey,\n      parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,\n      getNodeKey = _ref19.getNodeKey,\n      _ref19$ignoreCollapse = _ref19.ignoreCollapsed,\n      ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,\n      _ref19$expandParent = _ref19.expandParent,\n      expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,\n      _ref19$addAsFirstChil = _ref19.addAsFirstChild,\n      addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;\n\n  if (parentKey === null) {\n    return addAsFirstChild ? {\n      treeData: [newNode].concat(_toConsumableArray(treeData || [])),\n      treeIndex: 0\n    } : {\n      treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  var insertedTreeIndex = null;\n  var hasBeenAdded = false;\n  var changedTreeData = map({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(_ref20) {\n      var node = _ref20.node,\n          treeIndex = _ref20.treeIndex,\n          path = _ref20.path;\n      var key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is\n\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n\n      hasBeenAdded = true;\n\n      var parentNode = _objectSpread2({}, node);\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      } // If no children exist yet, just add the single newNode\n\n\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return _objectSpread2(_objectSpread2({}, parentNode), {}, {\n          children: [newNode]\n        });\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function');\n      }\n\n      var nextTreeIndex = treeIndex + 1;\n\n      for (var i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex += 1 + getDescendantCount({\n          node: parentNode.children[i],\n          ignoreCollapsed: ignoreCollapsed\n        });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n      var children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : [].concat(_toConsumableArray(parentNode.children), [newNode]);\n      return _objectSpread2(_objectSpread2({}, parentNode), {}, {\n        children: children\n      });\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.');\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex(_ref21) {\n  var targetDepth = _ref21.targetDepth,\n      minimumTreeIndex = _ref21.minimumTreeIndex,\n      newNode = _ref21.newNode,\n      ignoreCollapsed = _ref21.ignoreCollapsed,\n      expandParent = _ref21.expandParent,\n      _ref21$isPseudoRoot = _ref21.isPseudoRoot,\n      isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,\n      isLastChild = _ref21.isLastChild,\n      node = _ref21.node,\n      currentIndex = _ref21.currentIndex,\n      currentDepth = _ref21.currentDepth,\n      getNodeKey = _ref21.getNodeKey,\n      _ref21$path = _ref21.path,\n      path = _ref21$path === void 0 ? [] : _ref21$path;\n\n  var selfPath = function selfPath(n) {\n    return isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n      node: n,\n      treeIndex: currentIndex\n    })]);\n  }; // If the current position is the only possible place to add, add it\n\n\n  if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function');\n    } else {\n      var extraNodeProps = expandParent ? {\n        expanded: true\n      } : {};\n\n      var _nextNode = _objectSpread2(_objectSpread2(_objectSpread2({}, node), extraNodeProps), {}, {\n        children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n      });\n\n      return {\n        node: _nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(_nextNode),\n        parentNode: isPseudoRoot ? null : _nextNode\n      };\n    }\n  } // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n\n\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n      return {\n        node: node,\n        nextIndex: currentIndex + 1\n      };\n    } // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n\n\n    var _childIndex = currentIndex + 1;\n\n    var _insertedTreeIndex = null;\n    var insertIndex = null;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (_childIndex >= minimumTreeIndex) {\n        _insertedTreeIndex = _childIndex;\n        insertIndex = i;\n        break;\n      } // Increment the index by the child itself plus the number of descendants it has\n\n\n      _childIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    } // If no valid indices to add the node were found\n\n\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (_childIndex < minimumTreeIndex && !isLastChild) {\n        return {\n          node: node,\n          nextIndex: _childIndex\n        };\n      } // Use the last position in the children array to insert the newNode\n\n\n      _insertedTreeIndex = _childIndex;\n      insertIndex = node.children.length;\n    } // Insert the newNode at the insertIndex\n\n\n    var _nextNode2 = _objectSpread2(_objectSpread2({}, node), {}, {\n      children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))\n    }); // Return node with successful insert result\n\n\n    return {\n      node: _nextNode2,\n      nextIndex: _childIndex,\n      insertedTreeIndex: _insertedTreeIndex,\n      parentPath: selfPath(_nextNode2),\n      parentNode: isPseudoRoot ? null : _nextNode2\n    };\n  } // Skip over nodes with no children or hidden children\n\n\n  if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      node: node,\n      nextIndex: currentIndex + 1\n    };\n  } // Get all descendants\n\n\n  var insertedTreeIndex = null;\n  var pathFragment = null;\n  var parentNode = null;\n  var childIndex = currentIndex + 1;\n  var newChildren = node.children;\n\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map(function (child, i) {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      var mapResult = addNodeAtDepthAndIndex({\n        targetDepth: targetDepth,\n        minimumTreeIndex: minimumTreeIndex,\n        newNode: newNode,\n        ignoreCollapsed: ignoreCollapsed,\n        expandParent: expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey: getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n\n      });\n\n      if ('insertedTreeIndex' in mapResult) {\n        insertedTreeIndex = mapResult.insertedTreeIndex;\n        parentNode = mapResult.parentNode;\n        pathFragment = mapResult.parentPath;\n      }\n\n      childIndex = mapResult.nextIndex;\n      return mapResult.node;\n    });\n  }\n\n  var nextNode = _objectSpread2(_objectSpread2({}, node), {}, {\n    children: newChildren\n  });\n\n  var result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = [].concat(_toConsumableArray(selfPath(nextNode)), _toConsumableArray(pathFragment));\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\n\n\nfunction insertNode(_ref22) {\n  var treeData = _ref22.treeData,\n      targetDepth = _ref22.depth,\n      minimumTreeIndex = _ref22.minimumTreeIndex,\n      newNode = _ref22.newNode,\n      _ref22$getNodeKey = _ref22.getNodeKey,\n      getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,\n      _ref22$ignoreCollapse = _ref22.ignoreCollapsed,\n      ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,\n      _ref22$expandParent = _ref22.expandParent,\n      expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;\n\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({\n        node: newNode,\n        treeIndex: 0\n      })],\n      parentNode: null\n    };\n  }\n\n  var insertResult = addNodeAtDepthAndIndex({\n    targetDepth: targetDepth,\n    minimumTreeIndex: minimumTreeIndex,\n    newNode: newNode,\n    ignoreCollapsed: ignoreCollapsed,\n    expandParent: expandParent,\n    getNodeKey: getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.');\n  }\n\n  var treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex: treeIndex,\n    path: [].concat(_toConsumableArray(insertResult.parentPath), [getNodeKey({\n      node: newNode,\n      treeIndex: treeIndex\n    })]),\n    parentNode: insertResult.parentNode\n  };\n}\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\n\n\nfunction getFlatDataFromTree(_ref23) {\n  var treeData = _ref23.treeData,\n      getNodeKey = _ref23.getNodeKey,\n      _ref23$ignoreCollapse = _ref23.ignoreCollapsed,\n      ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  var flattened = [];\n  walk({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(nodeInfo) {\n      flattened.push(nodeInfo);\n    }\n  });\n  return flattened;\n}\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\n\n\nfunction getTreeFromFlatData(_ref24) {\n  var flatData = _ref24.flatData,\n      _ref24$getKey = _ref24.getKey,\n      getKey = _ref24$getKey === void 0 ? function (node) {\n    return node.id;\n  } : _ref24$getKey,\n      _ref24$getParentKey = _ref24.getParentKey,\n      getParentKey = _ref24$getParentKey === void 0 ? function (node) {\n    return node.parentId;\n  } : _ref24$getParentKey,\n      _ref24$rootKey = _ref24.rootKey,\n      rootKey = _ref24$rootKey === void 0 ? '0' : _ref24$rootKey;\n\n  if (!flatData) {\n    return [];\n  }\n\n  var childrenToParents = {};\n  flatData.forEach(function (child) {\n    var parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  var trav = function trav(parent) {\n    var parentKey = getKey(parent);\n\n    if (parentKey in childrenToParents) {\n      return _objectSpread2(_objectSpread2({}, parent), {}, {\n        children: childrenToParents[parentKey].map(function (child) {\n          return trav(child);\n        })\n      });\n    }\n\n    return _objectSpread2({}, parent);\n  };\n\n  return childrenToParents[rootKey].map(function (child) {\n    return trav(child);\n  });\n}\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\n\n\nfunction isDescendant(older, younger) {\n  return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n    return child === younger || isDescendant(child, younger);\n  });\n}\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\n\n\nfunction getDepth(node) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1;\n  }\n\n  return node.children.reduce(function (deepest, child) {\n    return Math.max(deepest, getDepth(child, depth + 1));\n  }, depth);\n}\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\n\n\nfunction find(_ref25) {\n  var getNodeKey = _ref25.getNodeKey,\n      treeData = _ref25.treeData,\n      searchQuery = _ref25.searchQuery,\n      searchMethod = _ref25.searchMethod,\n      searchFocusOffset = _ref25.searchFocusOffset,\n      _ref25$expandAllMatch = _ref25.expandAllMatchPaths,\n      expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,\n      _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,\n      expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;\n  var matchCount = 0;\n\n  var trav = function trav(_ref26) {\n    var _ref26$isPseudoRoot = _ref26.isPseudoRoot,\n        isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,\n        node = _ref26.node,\n        currentIndex = _ref26.currentIndex,\n        _ref26$path = _ref26.path,\n        path = _ref26$path === void 0 ? [] : _ref26$path;\n    var matches = [];\n    var isSelfMatch = false;\n    var hasFocusMatch = false; // The pseudo-root is not considered in the path\n\n    var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n      node: node,\n      treeIndex: currentIndex\n    })]);\n    var extraInfo = isPseudoRoot ? null : {\n      path: selfPath,\n      treeIndex: currentIndex\n    }; // Nodes with with children that aren't lazy\n\n    var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0; // Examine the current node to see if it is a match\n\n    if (!isPseudoRoot && searchMethod(_objectSpread2(_objectSpread2({}, extraInfo), {}, {\n      node: node,\n      searchQuery: searchQuery\n    }))) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      } // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n\n\n      matchCount += 1; // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n\n      isSelfMatch = true;\n    }\n\n    var childIndex = currentIndex;\n\n    var newNode = _objectSpread2({}, node);\n\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(function (child) {\n        var mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));\n\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          } // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n\n\n          if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    } // Cannot assign a treeIndex to hidden nodes\n\n\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(function (match) {\n        return _objectSpread2(_objectSpread2({}, match), {}, {\n          treeIndex: null\n        });\n      });\n    } // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n\n\n    if (isSelfMatch) {\n      matches = [_objectSpread2(_objectSpread2({}, extraInfo), {}, {\n        node: newNode\n      })].concat(_toConsumableArray(matches));\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches: matches,\n      hasFocusMatch: hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  var result = trav({\n    node: {\n      children: treeData\n    },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n} // very simple className utility for creating a classname string...\n// Falsy arguments are ignored:\n//\n// const active = true\n// const className = classnames(\n//    \"class1\",\n//    !active && \"class2\",\n//    active && \"class3\"\n// ); // returns -> class1 class3\";\n//\n\n\nfunction classnames() {\n  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n    classes[_key] = arguments[_key];\n  } // Use Boolean constructor as a filter callback\n  // Allows for loose type truthy/falsey checks\n  // Boolean(\"\") === false;\n  // Boolean(false) === false;\n  // Boolean(undefined) === false;\n  // Boolean(null) === false;\n  // Boolean(0) === false;\n  // Boolean(\"classname\") === true;\n\n\n  return classes.filter(Boolean).join(' ');\n}\n\nfunction _createSuper(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar NodeRendererDefault = /*#__PURE__*/function (_Component) {\n  _inherits(NodeRendererDefault, _Component);\n\n  var _super = _createSuper(NodeRendererDefault);\n\n  function NodeRendererDefault() {\n    _classCallCheck(this, NodeRendererDefault);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NodeRendererDefault, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          toggleChildrenVisibility = _this$props.toggleChildrenVisibility,\n          connectDragPreview = _this$props.connectDragPreview,\n          connectDragSource = _this$props.connectDragSource,\n          isDragging = _this$props.isDragging,\n          canDrop = _this$props.canDrop,\n          canDrag = _this$props.canDrag,\n          node = _this$props.node,\n          title = _this$props.title,\n          subtitle = _this$props.subtitle,\n          draggedNode = _this$props.draggedNode,\n          path = _this$props.path,\n          treeIndex = _this$props.treeIndex,\n          isSearchMatch = _this$props.isSearchMatch,\n          isSearchFocus = _this$props.isSearchFocus,\n          buttons = _this$props.buttons,\n          className = _this$props.className,\n          style = _this$props.style,\n          didDrop = _this$props.didDrop,\n          treeId = _this$props.treeId,\n          isOver = _this$props.isOver,\n          parentNode = _this$props.parentNode,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"scaffoldBlockPxWidth\", \"toggleChildrenVisibility\", \"connectDragPreview\", \"connectDragSource\", \"isDragging\", \"canDrop\", \"canDrag\", \"node\", \"title\", \"subtitle\", \"draggedNode\", \"path\", \"treeIndex\", \"isSearchMatch\", \"isSearchFocus\", \"buttons\", \"className\", \"style\", \"didDrop\", \"treeId\", \"isOver\", \"parentNode\", \"rowDirection\"]);\n\n      var nodeTitle = title || node.title;\n      var nodeSubtitle = subtitle || node.subtitle;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var handle;\n\n      if (canDrag) {\n        if (typeof node.children === 'function' && node.expanded) {\n          // Show a loading symbol on the handle when the children are expanded\n          //  and yet still defined by a function (a callback to fetch the children)\n          handle = React.createElement(\"div\", {\n            className: \"rst__loadingHandle\"\n          }, React.createElement(\"div\", {\n            className: \"rst__loadingCircle\"\n          }, _toConsumableArray(new Array(12)).map(function (_, index) {\n            return React.createElement(\"div\", {\n              // eslint-disable-next-line react/no-array-index-key\n              key: index,\n              className: classnames('rst__loadingCirclePoint', rowDirectionClass)\n            });\n          })));\n        } else {\n          // Show the handle used to initiate a drag-and-drop\n          handle = connectDragSource(React.createElement(\"div\", {\n            className: \"rst__moveHandle\"\n          }), {\n            dropEffect: 'copy'\n          });\n        }\n      }\n\n      var isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\n      var isLandingPadActive = !didDrop && isDragging;\n      var buttonStyle = {\n        left: -0.5 * scaffoldBlockPxWidth\n      };\n\n      if (rowDirection === 'rtl') {\n        buttonStyle = {\n          right: -0.5 * scaffoldBlockPxWidth\n        };\n      }\n\n      return React.createElement(\"div\", _extends({\n        style: {\n          height: '100%'\n        }\n      }, otherProps), toggleChildrenVisibility && node.children && (node.children.length > 0 || typeof node.children === 'function') && React.createElement(\"div\", null, React.createElement(\"button\", {\n        type: \"button\",\n        \"aria-label\": node.expanded ? 'Collapse' : 'Expand',\n        className: classnames(node.expanded ? 'rst__collapseButton' : 'rst__expandButton', rowDirectionClass),\n        style: buttonStyle,\n        onClick: function onClick() {\n          return toggleChildrenVisibility({\n            node: node,\n            path: path,\n            treeIndex: treeIndex\n          });\n        }\n      }), node.expanded && !isDragging && React.createElement(\"div\", {\n        style: {\n          width: scaffoldBlockPxWidth\n        },\n        className: classnames('rst__lineChildren', rowDirectionClass)\n      })), React.createElement(\"div\", {\n        className: classnames('rst__rowWrapper', rowDirectionClass)\n      }, connectDragPreview(React.createElement(\"div\", {\n        className: classnames('rst__row', isLandingPadActive && 'rst__rowLandingPad', isLandingPadActive && !canDrop && 'rst__rowCancelPad', isSearchMatch && 'rst__rowSearchMatch', isSearchFocus && 'rst__rowSearchFocus', rowDirectionClass, className),\n        style: _objectSpread2({\n          opacity: isDraggedDescendant ? 0.5 : 1\n        }, style)\n      }, handle, React.createElement(\"div\", {\n        className: classnames('rst__rowContents', !canDrag && 'rst__rowContentsDragDisabled', rowDirectionClass)\n      }, React.createElement(\"div\", {\n        className: classnames('rst__rowLabel', rowDirectionClass)\n      }, React.createElement(\"span\", {\n        className: classnames('rst__rowTitle', node.subtitle && 'rst__rowTitleWithSubtitle')\n      }, typeof nodeTitle === 'function' ? nodeTitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeTitle), nodeSubtitle && React.createElement(\"span\", {\n        className: \"rst__rowSubtitle\"\n      }, typeof nodeSubtitle === 'function' ? nodeSubtitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeSubtitle)), React.createElement(\"div\", {\n        className: \"rst__rowToolbar\"\n      }, buttons.map(function (btn, index) {\n        return React.createElement(\"div\", {\n          key: index // eslint-disable-line react/no-array-index-key\n          ,\n          className: \"rst__toolbarButton\"\n        }, btn);\n      })))))));\n    }\n  }]);\n\n  return NodeRendererDefault;\n}(Component);\n\nNodeRendererDefault.defaultProps = {\n  isSearchMatch: false,\n  isSearchFocus: false,\n  canDrag: false,\n  toggleChildrenVisibility: null,\n  buttons: [],\n  className: '',\n  style: {},\n  parentNode: null,\n  draggedNode: null,\n  canDrop: false,\n  title: null,\n  subtitle: null,\n  rowDirection: 'ltr'\n};\nNodeRendererDefault.propTypes = {\n  node: PropTypes.shape({}).isRequired,\n  title: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  subtitle: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  isSearchMatch: PropTypes.bool,\n  isSearchFocus: PropTypes.bool,\n  canDrag: PropTypes.bool,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  toggleChildrenVisibility: PropTypes.func,\n  buttons: PropTypes.arrayOf(PropTypes.node),\n  className: PropTypes.string,\n  style: PropTypes.shape({}),\n  // Drag and drop API functions\n  // Drag source\n  connectDragPreview: PropTypes.func.isRequired,\n  connectDragSource: PropTypes.func.isRequired,\n  parentNode: PropTypes.shape({}),\n  // Needed for dndManager\n  isDragging: PropTypes.bool.isRequired,\n  didDrop: PropTypes.bool.isRequired,\n  draggedNode: PropTypes.shape({}),\n  // Drop target\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nvar PlaceholderRendererDefault = function PlaceholderRendererDefault(_ref) {\n  var isOver = _ref.isOver,\n      canDrop = _ref.canDrop;\n  return React.createElement(\"div\", {\n    className: classnames('rst__placeholder', canDrop && 'rst__placeholderLandingPad', canDrop && !isOver && 'rst__placeholderCancelPad')\n  });\n};\n\nPlaceholderRendererDefault.defaultProps = {\n  isOver: false,\n  canDrop: false\n};\nPlaceholderRendererDefault.propTypes = {\n  isOver: PropTypes.bool,\n  canDrop: PropTypes.bool\n};\n\nfunction _createSuper$1(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar TreeNode = /*#__PURE__*/function (_Component) {\n  _inherits(TreeNode, _Component);\n\n  var _super = _createSuper$1(TreeNode);\n\n  function TreeNode() {\n    _classCallCheck(this, TreeNode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TreeNode, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          listIndex = _this$props.listIndex,\n          swapFrom = _this$props.swapFrom,\n          swapLength = _this$props.swapLength,\n          swapDepth = _this$props.swapDepth,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          lowerSiblingCounts = _this$props.lowerSiblingCounts,\n          connectDropTarget = _this$props.connectDropTarget,\n          isOver = _this$props.isOver,\n          draggedNode = _this$props.draggedNode,\n          canDrop = _this$props.canDrop,\n          treeIndex = _this$props.treeIndex,\n          treeId = _this$props.treeId,\n          getPrevRow = _this$props.getPrevRow,\n          node = _this$props.node,\n          path = _this$props.path,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"listIndex\", \"swapFrom\", \"swapLength\", \"swapDepth\", \"scaffoldBlockPxWidth\", \"lowerSiblingCounts\", \"connectDropTarget\", \"isOver\", \"draggedNode\", \"canDrop\", \"treeIndex\", \"treeId\", \"getPrevRow\", \"node\", \"path\", \"rowDirection\"]);\n\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null; // Construct the scaffold representing the structure of the tree\n\n      var scaffoldBlockCount = lowerSiblingCounts.length;\n      var scaffold = [];\n      lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n        var lineClass = '';\n\n        if (lowerSiblingCount > 0) {\n          // At this level in the tree, the nodes had sibling nodes further down\n          if (listIndex === 0) {\n            // Top-left corner of the tree\n            // +-----+\n            // |     |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineHalfVerticalBottom';\n          } else if (i === scaffoldBlockCount - 1) {\n            // Last scaffold block in the row, right before the row content\n            // +--+--+\n            // |  |  |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineFullVertical';\n          } else {\n            // Simply connecting the line extending down to the next sibling on this level\n            // +--+--+\n            // |  |  |\n            // |  |  |\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineFullVertical';\n          }\n        } else if (listIndex === 0) {\n          // Top-left corner of the tree, but has no siblings\n          // +-----+\n          // |     |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfHorizontalRight';\n        } else if (i === scaffoldBlockCount - 1) {\n          // The last or only node in this level of the tree\n          // +--+--+\n          // |  |  |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfVerticalTop rst__lineHalfHorizontalRight';\n        }\n\n        scaffold.push(React.createElement(\"div\", {\n          key: \"pre_\".concat(1 + i),\n          style: {\n            width: scaffoldBlockPxWidth\n          },\n          className: classnames('rst__lineBlock', lineClass, rowDirectionClass)\n        }));\n\n        if (treeIndex !== listIndex && i === swapDepth) {\n          // This row has been shifted, and is at the depth of\n          // the line pointing to the new destination\n          var highlightLineClass = '';\n\n          if (listIndex === swapFrom + swapLength - 1) {\n            // This block is on the bottom (target) line\n            // This block points at the target block (where the row will go when released)\n            highlightLineClass = 'rst__highlightBottomLeftCorner';\n          } else if (treeIndex === swapFrom) {\n            // This block is on the top (source) line\n            highlightLineClass = 'rst__highlightTopLeftCorner';\n          } else {\n            // This block is between the bottom and top\n            highlightLineClass = 'rst__highlightLineVertical';\n          }\n\n          var _style;\n\n          if (rowDirection === 'rtl') {\n            _style = {\n              width: scaffoldBlockPxWidth,\n              right: scaffoldBlockPxWidth * i\n            };\n          } else {\n            // Default ltr\n            _style = {\n              width: scaffoldBlockPxWidth,\n              left: scaffoldBlockPxWidth * i\n            };\n          }\n\n          scaffold.push(React.createElement(\"div\", {\n            // eslint-disable-next-line react/no-array-index-key\n            key: i,\n            style: _style,\n            className: classnames('rst__absoluteLineBlock', highlightLineClass, rowDirectionClass)\n          }));\n        }\n      });\n      var style;\n\n      if (rowDirection === 'rtl') {\n        style = {\n          right: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      } else {\n        // Default ltr\n        style = {\n          left: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      }\n\n      return connectDropTarget(React.createElement(\"div\", _extends({}, otherProps, {\n        className: classnames('rst__node', rowDirectionClass)\n      }), scaffold, React.createElement(\"div\", {\n        className: \"rst__nodeContent\",\n        style: style\n      }, Children.map(children, function (child) {\n        return cloneElement(child, {\n          isOver: isOver,\n          canDrop: canDrop,\n          draggedNode: draggedNode\n        });\n      }))));\n    }\n  }]);\n\n  return TreeNode;\n}(Component);\n\nTreeNode.defaultProps = {\n  swapFrom: null,\n  swapDepth: null,\n  swapLength: null,\n  canDrop: false,\n  draggedNode: null,\n  rowDirection: 'ltr'\n};\nTreeNode.propTypes = {\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  swapFrom: PropTypes.number,\n  swapDepth: PropTypes.number,\n  swapLength: PropTypes.number,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  lowerSiblingCounts: PropTypes.arrayOf(PropTypes.number).isRequired,\n  listIndex: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  // used in dndManager\n  getPrevRow: PropTypes.func.isRequired,\n  node: PropTypes.shape({}).isRequired,\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nfunction _createSuper$2(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar TreePlaceholder = /*#__PURE__*/function (_Component) {\n  _inherits(TreePlaceholder, _Component);\n\n  var _super = _createSuper$2(TreePlaceholder);\n\n  function TreePlaceholder() {\n    _classCallCheck(this, TreePlaceholder);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TreePlaceholder, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          connectDropTarget = _this$props.connectDropTarget,\n          treeId = _this$props.treeId,\n          drop = _this$props.drop,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"connectDropTarget\", \"treeId\", \"drop\"]);\n\n      return connectDropTarget(React.createElement(\"div\", null, Children.map(children, function (child) {\n        return cloneElement(child, _objectSpread2({}, otherProps));\n      })));\n    }\n  }]);\n\n  return TreePlaceholder;\n}(Component);\n\nTreePlaceholder.defaultProps = {\n  canDrop: false,\n  draggedNode: null\n};\nTreePlaceholder.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  treeId: PropTypes.string.isRequired,\n  drop: PropTypes.func.isRequired\n};\n\nfunction defaultGetNodeKey(_ref) {\n  var treeIndex = _ref.treeIndex;\n  return treeIndex;\n} // Cheap hack to get the text of a react object\n\n\nfunction getReactElementText(parent) {\n  if (typeof parent === 'string') {\n    return parent;\n  }\n\n  if (parent === null || _typeof(parent) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n    return '';\n  }\n\n  if (typeof parent.props.children === 'string') {\n    return parent.props.children;\n  }\n\n  return parent.props.children.map(function (child) {\n    return getReactElementText(child);\n  }).join('');\n} // Search for a query string inside a node property\n\n\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n  if (typeof node[key] === 'function') {\n    // Search within text after calling its function to generate the text\n    return String(node[key]({\n      node: node,\n      path: path,\n      treeIndex: treeIndex\n    })).indexOf(searchQuery) > -1;\n  }\n\n  if (_typeof(node[key]) === 'object') {\n    // Search within text inside react elements\n    return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n  } // Search within string\n\n\n  return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n}\n\nfunction defaultSearchMethod(_ref2) {\n  var node = _ref2.node,\n      path = _ref2.path,\n      treeIndex = _ref2.treeIndex,\n      searchQuery = _ref2.searchQuery;\n  return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n}\n\nvar memoize = function memoize(f) {\n  var savedArgsArray = [];\n  var savedKeysArray = [];\n  var savedResult = null;\n  return function (args) {\n    var keysArray = Object.keys(args).sort();\n    var argsArray = keysArray.map(function (key) {\n      return args[key];\n    }); // If the arguments for the last insert operation are different than this time,\n    // recalculate the result\n\n    if (argsArray.length !== savedArgsArray.length || argsArray.some(function (arg, index) {\n      return arg !== savedArgsArray[index];\n    }) || keysArray.some(function (key, index) {\n      return key !== savedKeysArray[index];\n    })) {\n      savedArgsArray = argsArray;\n      savedKeysArray = keysArray;\n      savedResult = f(args);\n    }\n\n    return savedResult;\n  };\n};\n\nvar memoizedInsertNode = memoize(insertNode);\nvar memoizedGetFlatDataFromTree = memoize(getFlatDataFromTree);\nvar memoizedGetDescendantCount = memoize(getDescendantCount);\n\nvar DndManager = /*#__PURE__*/function () {\n  function DndManager(treeRef) {\n    _classCallCheck(this, DndManager);\n\n    this.treeRef = treeRef;\n  }\n\n  _createClass(DndManager, [{\n    key: \"getTargetDepth\",\n    value: function getTargetDepth(dropTargetProps, monitor, component) {\n      var dropTargetDepth = 0;\n      var rowAbove = dropTargetProps.getPrevRow();\n\n      if (rowAbove) {\n        var path = rowAbove.path;\n        var aboveNodeCannotHaveChildren = !this.treeRef.canNodeHaveChildren(rowAbove.node);\n\n        if (aboveNodeCannotHaveChildren) {\n          path = path.slice(0, path.length - 1);\n        } // Limit the length of the path to the deepest possible\n\n\n        dropTargetDepth = Math.min(path.length, dropTargetProps.path.length);\n      }\n\n      var blocksOffset;\n      var dragSourceInitialDepth = (monitor.getItem().path || []).length; // When adding node from external source\n\n      if (monitor.getItem().treeId !== this.treeId) {\n        // Ignore the tree depth of the source, if it had any to begin with\n        dragSourceInitialDepth = 0;\n\n        if (component) {\n          var relativePosition = findDOMNode(component).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node\n\n          var leftShift = monitor.getSourceClientOffset().x - relativePosition.left;\n          blocksOffset = Math.round(leftShift / dropTargetProps.scaffoldBlockPxWidth);\n        } else {\n          blocksOffset = dropTargetProps.path.length;\n        }\n      } else {\n        // handle row direction support\n        var direction = dropTargetProps.rowDirection === 'rtl' ? -1 : 1;\n        blocksOffset = Math.round(direction * monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n      }\n\n      var targetDepth = Math.min(dropTargetDepth, Math.max(0, dragSourceInitialDepth + blocksOffset - 1)); // If a maxDepth is defined, constrain the target depth\n\n      if (typeof this.maxDepth !== 'undefined' && this.maxDepth !== null) {\n        var draggedNode = monitor.getItem().node;\n        var draggedChildDepth = getDepth(draggedNode);\n        targetDepth = Math.max(0, Math.min(targetDepth, this.maxDepth - draggedChildDepth - 1));\n      }\n\n      return targetDepth;\n    }\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dropTargetProps, monitor) {\n      if (!monitor.isOver()) {\n        return false;\n      }\n\n      var rowAbove = dropTargetProps.getPrevRow();\n      var abovePath = rowAbove ? rowAbove.path : [];\n      var aboveNode = rowAbove ? rowAbove.node : {};\n      var targetDepth = this.getTargetDepth(dropTargetProps, monitor, null); // Cannot drop if we're adding to the children of the row above and\n      //  the row above is a function\n\n      if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\n        return false;\n      }\n\n      if (typeof this.customCanDrop === 'function') {\n        var _monitor$getItem = monitor.getItem(),\n            node = _monitor$getItem.node;\n\n        var addedResult = memoizedInsertNode({\n          treeData: this.treeData,\n          newNode: node,\n          depth: targetDepth,\n          getNodeKey: this.getNodeKey,\n          minimumTreeIndex: dropTargetProps.listIndex,\n          expandParent: true\n        });\n        return this.customCanDrop({\n          node: node,\n          prevPath: monitor.getItem().path,\n          prevParent: monitor.getItem().parentNode,\n          prevTreeIndex: monitor.getItem().treeIndex,\n          // Equals -1 when dragged from external tree\n          nextPath: addedResult.path,\n          nextParent: addedResult.parentNode,\n          nextTreeIndex: addedResult.treeIndex\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"wrapSource\",\n    value: function wrapSource(el) {\n      var _this = this;\n\n      var nodeDragSource = {\n        beginDrag: function beginDrag(props) {\n          _this.startDrag(props);\n\n          return {\n            node: props.node,\n            parentNode: props.parentNode,\n            path: props.path,\n            treeIndex: props.treeIndex,\n            treeId: props.treeId\n          };\n        },\n        endDrag: function endDrag(props, monitor) {\n          _this.endDrag(monitor.getDropResult());\n        },\n        isDragging: function isDragging(props, monitor) {\n          var dropTargetNode = monitor.getItem().node;\n          var draggedNode = props.node;\n          return draggedNode === dropTargetNode;\n        }\n      };\n\n      function nodeDragSourcePropInjection(connect, monitor) {\n        return {\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n          didDrop: monitor.didDrop()\n        };\n      }\n\n      return DragSource(this.dndType, nodeDragSource, nodeDragSourcePropInjection)(el);\n    }\n  }, {\n    key: \"wrapTarget\",\n    value: function wrapTarget(el) {\n      var _this2 = this;\n\n      var nodeDropTarget = {\n        drop: function drop(dropTargetProps, monitor, component) {\n          var result = {\n            node: monitor.getItem().node,\n            path: monitor.getItem().path,\n            treeIndex: monitor.getItem().treeIndex,\n            treeId: _this2.treeId,\n            minimumTreeIndex: dropTargetProps.treeIndex,\n            depth: _this2.getTargetDepth(dropTargetProps, monitor, component)\n          };\n\n          _this2.drop(result);\n\n          return result;\n        },\n        hover: function hover(dropTargetProps, monitor, component) {\n          var targetDepth = _this2.getTargetDepth(dropTargetProps, monitor, component);\n\n          var draggedNode = monitor.getItem().node;\n          var needsRedraw = // Redraw if hovered above different nodes\n          dropTargetProps.node !== draggedNode || // Or hovered above the same node but at a different depth\n          targetDepth !== dropTargetProps.path.length - 1;\n\n          if (!needsRedraw) {\n            return;\n          } // throttle `dragHover` work to available animation frames\n\n\n          cancelAnimationFrame(_this2.rafId);\n          _this2.rafId = requestAnimationFrame(function () {\n            _this2.dragHover({\n              node: draggedNode,\n              path: monitor.getItem().path,\n              minimumTreeIndex: dropTargetProps.listIndex,\n              depth: targetDepth\n            });\n          });\n        },\n        canDrop: this.canDrop.bind(this)\n      };\n\n      function nodeDropTargetPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, nodeDropTarget, nodeDropTargetPropInjection)(el);\n    }\n  }, {\n    key: \"wrapPlaceholder\",\n    value: function wrapPlaceholder(el) {\n      var _this3 = this;\n\n      var placeholderDropTarget = {\n        drop: function drop(dropTargetProps, monitor) {\n          var _monitor$getItem2 = monitor.getItem(),\n              node = _monitor$getItem2.node,\n              path = _monitor$getItem2.path,\n              treeIndex = _monitor$getItem2.treeIndex;\n\n          var result = {\n            node: node,\n            path: path,\n            treeIndex: treeIndex,\n            treeId: _this3.treeId,\n            minimumTreeIndex: 0,\n            depth: 0\n          };\n\n          _this3.drop(result);\n\n          return result;\n        }\n      };\n\n      function placeholderPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, placeholderDropTarget, placeholderPropInjection)(el);\n    }\n  }, {\n    key: \"startDrag\",\n    get: function get() {\n      return this.treeRef.startDrag;\n    }\n  }, {\n    key: \"dragHover\",\n    get: function get() {\n      return this.treeRef.dragHover;\n    }\n  }, {\n    key: \"endDrag\",\n    get: function get() {\n      return this.treeRef.endDrag;\n    }\n  }, {\n    key: \"drop\",\n    get: function get() {\n      return this.treeRef.drop;\n    }\n  }, {\n    key: \"treeId\",\n    get: function get() {\n      return this.treeRef.treeId;\n    }\n  }, {\n    key: \"dndType\",\n    get: function get() {\n      return this.treeRef.dndType;\n    }\n  }, {\n    key: \"treeData\",\n    get: function get() {\n      return this.treeRef.state.draggingTreeData || this.treeRef.props.treeData;\n    }\n  }, {\n    key: \"getNodeKey\",\n    get: function get() {\n      return this.treeRef.props.getNodeKey;\n    }\n  }, {\n    key: \"customCanDrop\",\n    get: function get() {\n      return this.treeRef.props.canDrop;\n    }\n  }, {\n    key: \"maxDepth\",\n    get: function get() {\n      return this.treeRef.props.maxDepth;\n    }\n  }]);\n\n  return DndManager;\n}();\n/* eslint-disable import/prefer-default-export */\n\n\nfunction slideRows(rows, fromIndex, toIndex) {\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var rowsWithoutMoved = [].concat(_toConsumableArray(rows.slice(0, fromIndex)), _toConsumableArray(rows.slice(fromIndex + count)));\n  return [].concat(_toConsumableArray(rowsWithoutMoved.slice(0, toIndex)), _toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n}\n\nfunction _createSuper$3(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar treeIdCounter = 1;\n\nvar mergeTheme = function mergeTheme(props) {\n  var merged = _objectSpread2(_objectSpread2({}, props), {}, {\n    style: _objectSpread2(_objectSpread2({}, props.theme.style), props.style),\n    innerStyle: _objectSpread2(_objectSpread2({}, props.theme.innerStyle), props.innerStyle),\n    reactVirtualizedListProps: _objectSpread2(_objectSpread2({}, props.theme.reactVirtualizedListProps), props.reactVirtualizedListProps)\n  });\n\n  var overridableDefaults = {\n    nodeContentRenderer: NodeRendererDefault,\n    placeholderRenderer: PlaceholderRendererDefault,\n    rowHeight: 62,\n    scaffoldBlockPxWidth: 44,\n    slideRegionSize: 100,\n    treeNodeRenderer: TreeNode\n  };\n  Object.keys(overridableDefaults).forEach(function (propKey) {\n    // If prop has been specified, do not change it\n    // If prop is specified in theme, use the theme setting\n    // If all else fails, fall back to the default\n    if (props[propKey] === null) {\n      merged[propKey] = typeof props.theme[propKey] !== 'undefined' ? props.theme[propKey] : overridableDefaults[propKey];\n    }\n  });\n  return merged;\n};\n\nvar ReactSortableTree = /*#__PURE__*/function (_Component) {\n  _inherits(ReactSortableTree, _Component);\n\n  var _super = _createSuper$3(ReactSortableTree);\n\n  function ReactSortableTree(props) {\n    var _this;\n\n    _classCallCheck(this, ReactSortableTree);\n\n    _this = _super.call(this, props);\n\n    var _mergeTheme = mergeTheme(props),\n        dndType = _mergeTheme.dndType,\n        nodeContentRenderer = _mergeTheme.nodeContentRenderer,\n        treeNodeRenderer = _mergeTheme.treeNodeRenderer,\n        isVirtualized = _mergeTheme.isVirtualized,\n        slideRegionSize = _mergeTheme.slideRegionSize;\n\n    _this.dndManager = new DndManager(_assertThisInitialized(_this)); // Wrapping classes for use with react-dnd\n\n    _this.treeId = \"rst__\".concat(treeIdCounter);\n    treeIdCounter += 1;\n    _this.dndType = dndType || _this.treeId;\n    _this.nodeContentRenderer = _this.dndManager.wrapSource(nodeContentRenderer);\n    _this.treePlaceholderRenderer = _this.dndManager.wrapPlaceholder(TreePlaceholder);\n    _this.treeNodeRenderer = _this.dndManager.wrapTarget(treeNodeRenderer); // Prepare scroll-on-drag options for this list\n\n    if (isVirtualized) {\n      _this.scrollZoneVirtualList = (createScrollingComponent || withScrolling)(List);\n      _this.vStrength = createVerticalStrength(slideRegionSize);\n      _this.hStrength = createHorizontalStrength(slideRegionSize);\n    }\n\n    _this.state = {\n      draggingTreeData: null,\n      draggedNode: null,\n      draggedMinimumTreeIndex: null,\n      draggedDepth: null,\n      searchMatches: [],\n      searchFocusTreeIndex: null,\n      dragging: false,\n      // props that need to be used in gDSFP or static functions will be stored here\n      instanceProps: {\n        treeData: [],\n        ignoreOneTreeUpdate: false,\n        searchQuery: null,\n        searchFocusOffset: null\n      }\n    };\n    _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_assertThisInitialized(_this));\n    _this.moveNode = _this.moveNode.bind(_assertThisInitialized(_this));\n    _this.startDrag = _this.startDrag.bind(_assertThisInitialized(_this));\n    _this.dragHover = _this.dragHover.bind(_assertThisInitialized(_this));\n    _this.endDrag = _this.endDrag.bind(_assertThisInitialized(_this));\n    _this.drop = _this.drop.bind(_assertThisInitialized(_this));\n    _this.handleDndMonitorChange = _this.handleDndMonitorChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ReactSortableTree, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      ReactSortableTree.loadLazyChildren(this.props, this.state);\n      var stateUpdate = ReactSortableTree.search(this.props, this.state, true, true, false);\n      this.setState(stateUpdate); // Hook into react-dnd state changes to detect when the drag ends\n      // TODO: This is very brittle, so it needs to be replaced if react-dnd\n      // offers a more official way to detect when a drag ends\n\n      this.clearMonitorSubscription = this.props.dragDropManager.getMonitor().subscribeToStateChange(this.handleDndMonitorChange);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    // listen to dragging\n    value: function componentDidUpdate(prevProps, prevState) {\n      // if it is not the same then call the onDragStateChanged\n      if (this.state.dragging !== prevState.dragging) {\n        if (this.props.onDragStateChanged) {\n          this.props.onDragStateChanged({\n            isDragging: this.state.dragging,\n            draggedNode: this.state.draggedNode\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearMonitorSubscription();\n    }\n  }, {\n    key: \"getRows\",\n    value: function getRows(treeData) {\n      return memoizedGetFlatDataFromTree({\n        ignoreCollapsed: true,\n        getNodeKey: this.props.getNodeKey,\n        treeData: treeData\n      });\n    }\n  }, {\n    key: \"handleDndMonitorChange\",\n    value: function handleDndMonitorChange() {\n      var monitor = this.props.dragDropManager.getMonitor(); // If the drag ends and the tree is still in a mid-drag state,\n      // it means that the drag was canceled or the dragSource dropped\n      // elsewhere, and we should reset the state of this tree\n\n      if (!monitor.isDragging() && this.state.draggingTreeData) {\n        this.endDrag();\n      }\n    }\n  }, {\n    key: \"toggleChildrenVisibility\",\n    value: function toggleChildrenVisibility(_ref) {\n      var targetNode = _ref.node,\n          path = _ref.path;\n      var instanceProps = this.state.instanceProps;\n      var treeData = changeNodeAtPath({\n        treeData: instanceProps.treeData,\n        path: path,\n        newNode: function newNode(_ref2) {\n          var node = _ref2.node;\n          return _objectSpread2(_objectSpread2({}, node), {}, {\n            expanded: !node.expanded\n          });\n        },\n        getNodeKey: this.props.getNodeKey\n      });\n      this.props.onChange(treeData);\n      this.props.onVisibilityToggle({\n        treeData: treeData,\n        node: targetNode,\n        expanded: !targetNode.expanded,\n        path: path\n      });\n    }\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(_ref3) {\n      var node = _ref3.node,\n          prevPath = _ref3.path,\n          prevTreeIndex = _ref3.treeIndex,\n          depth = _ref3.depth,\n          minimumTreeIndex = _ref3.minimumTreeIndex;\n\n      var _insertNode = insertNode({\n        treeData: this.state.draggingTreeData,\n        newNode: node,\n        depth: depth,\n        minimumTreeIndex: minimumTreeIndex,\n        expandParent: true,\n        getNodeKey: this.props.getNodeKey\n      }),\n          treeData = _insertNode.treeData,\n          treeIndex = _insertNode.treeIndex,\n          path = _insertNode.path,\n          nextParentNode = _insertNode.parentNode;\n\n      this.props.onChange(treeData);\n      this.props.onMoveNode({\n        treeData: treeData,\n        node: node,\n        treeIndex: treeIndex,\n        path: path,\n        nextPath: path,\n        nextTreeIndex: treeIndex,\n        prevPath: prevPath,\n        prevTreeIndex: prevTreeIndex,\n        nextParentNode: nextParentNode\n      });\n    } // returns the new state after search\n\n  }, {\n    key: \"startDrag\",\n    value: function startDrag(_ref4) {\n      var _this2 = this;\n\n      var path = _ref4.path;\n      this.setState(function (prevState) {\n        var _removeNode = removeNode({\n          treeData: prevState.instanceProps.treeData,\n          path: path,\n          getNodeKey: _this2.props.getNodeKey\n        }),\n            draggingTreeData = _removeNode.treeData,\n            draggedNode = _removeNode.node,\n            draggedMinimumTreeIndex = _removeNode.treeIndex;\n\n        return {\n          draggingTreeData: draggingTreeData,\n          draggedNode: draggedNode,\n          draggedDepth: path.length - 1,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"dragHover\",\n    value: function dragHover(_ref5) {\n      var _this3 = this;\n\n      var draggedNode = _ref5.node,\n          draggedDepth = _ref5.depth,\n          draggedMinimumTreeIndex = _ref5.minimumTreeIndex; // Ignore this hover if it is at the same position as the last hover\n\n      if (this.state.draggedDepth === draggedDepth && this.state.draggedMinimumTreeIndex === draggedMinimumTreeIndex) {\n        return;\n      }\n\n      this.setState(function (_ref6) {\n        var draggingTreeData = _ref6.draggingTreeData,\n            instanceProps = _ref6.instanceProps; // Fall back to the tree data if something is being dragged in from\n        //  an external element\n\n        var newDraggingTreeData = draggingTreeData || instanceProps.treeData;\n        var addedResult = memoizedInsertNode({\n          treeData: newDraggingTreeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: _this3.props.getNodeKey\n        });\n\n        var rows = _this3.getRows(addedResult.treeData);\n\n        var expandedParentPath = rows[addedResult.treeIndex].path;\n        return {\n          draggedNode: draggedNode,\n          draggedDepth: draggedDepth,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          draggingTreeData: changeNodeAtPath({\n            treeData: newDraggingTreeData,\n            path: expandedParentPath.slice(0, -1),\n            newNode: function newNode(_ref7) {\n              var node = _ref7.node;\n              return _objectSpread2(_objectSpread2({}, node), {}, {\n                expanded: true\n              });\n            },\n            getNodeKey: _this3.props.getNodeKey\n          }),\n          // reset the scroll focus so it doesn't jump back\n          // to a search result while dragging\n          searchFocusTreeIndex: null,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"endDrag\",\n    value: function endDrag(dropResult) {\n      var _this4 = this;\n\n      var instanceProps = this.state.instanceProps;\n\n      var resetTree = function resetTree() {\n        return _this4.setState({\n          draggingTreeData: null,\n          draggedNode: null,\n          draggedMinimumTreeIndex: null,\n          draggedDepth: null,\n          dragging: false\n        });\n      }; // Drop was cancelled\n\n\n      if (!dropResult) {\n        resetTree();\n      } else if (dropResult.treeId !== this.treeId) {\n        // The node was dropped in an external drop target or tree\n        var node = dropResult.node,\n            path = dropResult.path,\n            treeIndex = dropResult.treeIndex;\n        var shouldCopy = this.props.shouldCopyOnOutsideDrop;\n\n        if (typeof shouldCopy === 'function') {\n          shouldCopy = shouldCopy({\n            node: node,\n            prevTreeIndex: treeIndex,\n            prevPath: path\n          });\n        }\n\n        var treeData = this.state.draggingTreeData || instanceProps.treeData; // If copying is enabled, a drop outside leaves behind a copy in the\n        //  source tree\n\n        if (shouldCopy) {\n          treeData = changeNodeAtPath({\n            treeData: instanceProps.treeData,\n            // use treeData unaltered by the drag operation\n            path: path,\n            newNode: function newNode(_ref8) {\n              var copyNode = _ref8.node;\n              return _objectSpread2({}, copyNode);\n            },\n            // create a shallow copy of the node\n            getNodeKey: this.props.getNodeKey\n          });\n        }\n\n        this.props.onChange(treeData);\n        this.props.onMoveNode({\n          treeData: treeData,\n          node: node,\n          treeIndex: null,\n          path: null,\n          nextPath: null,\n          nextTreeIndex: null,\n          prevPath: path,\n          prevTreeIndex: treeIndex\n        });\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(dropResult) {\n      this.moveNode(dropResult);\n    }\n  }, {\n    key: \"canNodeHaveChildren\",\n    value: function canNodeHaveChildren(node) {\n      var canNodeHaveChildren = this.props.canNodeHaveChildren;\n\n      if (canNodeHaveChildren) {\n        return canNodeHaveChildren(node);\n      }\n\n      return true;\n    } // Load any children in the tree that are given by a function\n    // calls the onChange callback on the new treeData\n\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(row, _ref9) {\n      var listIndex = _ref9.listIndex,\n          style = _ref9.style,\n          getPrevRow = _ref9.getPrevRow,\n          matchKeys = _ref9.matchKeys,\n          swapFrom = _ref9.swapFrom,\n          swapDepth = _ref9.swapDepth,\n          swapLength = _ref9.swapLength;\n      var node = row.node,\n          parentNode = row.parentNode,\n          path = row.path,\n          lowerSiblingCounts = row.lowerSiblingCounts,\n          treeIndex = row.treeIndex;\n\n      var _mergeTheme2 = mergeTheme(this.props),\n          canDrag = _mergeTheme2.canDrag,\n          generateNodeProps = _mergeTheme2.generateNodeProps,\n          scaffoldBlockPxWidth = _mergeTheme2.scaffoldBlockPxWidth,\n          searchFocusOffset = _mergeTheme2.searchFocusOffset,\n          rowDirection = _mergeTheme2.rowDirection;\n\n      var TreeNodeRenderer = this.treeNodeRenderer;\n      var NodeContentRenderer = this.nodeContentRenderer;\n      var nodeKey = path[path.length - 1];\n      var isSearchMatch = (nodeKey in matchKeys);\n      var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\n      var callbackParams = {\n        node: node,\n        parentNode: parentNode,\n        path: path,\n        lowerSiblingCounts: lowerSiblingCounts,\n        treeIndex: treeIndex,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus\n      };\n      var nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\n      var rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\n      var sharedProps = {\n        treeIndex: treeIndex,\n        scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n        node: node,\n        path: path,\n        treeId: this.treeId,\n        rowDirection: rowDirection\n      };\n      return React.createElement(TreeNodeRenderer, _extends({\n        style: style,\n        key: nodeKey,\n        listIndex: listIndex,\n        getPrevRow: getPrevRow,\n        lowerSiblingCounts: lowerSiblingCounts,\n        swapFrom: swapFrom,\n        swapLength: swapLength,\n        swapDepth: swapDepth\n      }, sharedProps), React.createElement(NodeContentRenderer, _extends({\n        parentNode: parentNode,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus,\n        canDrag: rowCanDrag,\n        toggleChildrenVisibility: this.toggleChildrenVisibility\n      }, sharedProps, nodeProps)));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _mergeTheme3 = mergeTheme(this.props),\n          dragDropManager = _mergeTheme3.dragDropManager,\n          style = _mergeTheme3.style,\n          className = _mergeTheme3.className,\n          innerStyle = _mergeTheme3.innerStyle,\n          rowHeight = _mergeTheme3.rowHeight,\n          isVirtualized = _mergeTheme3.isVirtualized,\n          placeholderRenderer = _mergeTheme3.placeholderRenderer,\n          reactVirtualizedListProps = _mergeTheme3.reactVirtualizedListProps,\n          getNodeKey = _mergeTheme3.getNodeKey,\n          rowDirection = _mergeTheme3.rowDirection;\n\n      var _this$state = this.state,\n          searchMatches = _this$state.searchMatches,\n          searchFocusTreeIndex = _this$state.searchFocusTreeIndex,\n          draggedNode = _this$state.draggedNode,\n          draggedDepth = _this$state.draggedDepth,\n          draggedMinimumTreeIndex = _this$state.draggedMinimumTreeIndex,\n          instanceProps = _this$state.instanceProps;\n      var treeData = this.state.draggingTreeData || instanceProps.treeData;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var rows;\n      var swapFrom = null;\n      var swapLength = null;\n\n      if (draggedNode && draggedMinimumTreeIndex !== null) {\n        var addedResult = memoizedInsertNode({\n          treeData: treeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: getNodeKey\n        });\n        var swapTo = draggedMinimumTreeIndex;\n        swapFrom = addedResult.treeIndex;\n        swapLength = 1 + memoizedGetDescendantCount({\n          node: draggedNode\n        });\n        rows = slideRows(this.getRows(addedResult.treeData), swapFrom, swapTo, swapLength);\n      } else {\n        rows = this.getRows(treeData);\n      } // Get indices for rows that match the search conditions\n\n\n      var matchKeys = {};\n      searchMatches.forEach(function (_ref10, i) {\n        var path = _ref10.path;\n        matchKeys[path[path.length - 1]] = i;\n      }); // Seek to the focused search result if there is one specified\n\n      var scrollToInfo = searchFocusTreeIndex !== null ? {\n        scrollToIndex: searchFocusTreeIndex\n      } : {};\n      var containerStyle = style;\n      var list;\n\n      if (rows.length < 1) {\n        var Placeholder = this.treePlaceholderRenderer;\n        var PlaceholderContent = placeholderRenderer;\n        list = React.createElement(Placeholder, {\n          treeId: this.treeId,\n          drop: this.drop\n        }, React.createElement(PlaceholderContent, null));\n      } else if (isVirtualized) {\n        containerStyle = _objectSpread2({\n          height: '100%'\n        }, containerStyle);\n        var ScrollZoneVirtualList = this.scrollZoneVirtualList; // Render list with react-virtualized\n\n        list = React.createElement(AutoSizer, null, function (_ref11) {\n          var height = _ref11.height,\n              width = _ref11.width;\n          return React.createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {\n            dragDropManager: dragDropManager,\n            verticalStrength: _this5.vStrength,\n            horizontalStrength: _this5.hStrength,\n            speed: 30,\n            scrollToAlignment: \"start\",\n            className: \"rst__virtualScrollOverride\",\n            width: width,\n            onScroll: function onScroll(_ref12) {\n              var scrollTop = _ref12.scrollTop;\n              _this5.scrollTop = scrollTop;\n            },\n            height: height,\n            style: innerStyle,\n            rowCount: rows.length,\n            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,\n            rowHeight: typeof rowHeight !== 'function' ? rowHeight : function (_ref13) {\n              var index = _ref13.index;\n              return rowHeight({\n                index: index,\n                treeIndex: index,\n                node: rows[index].node,\n                path: rows[index].path\n              });\n            },\n            rowRenderer: function rowRenderer(_ref14) {\n              var index = _ref14.index,\n                  rowStyle = _ref14.style;\n              return _this5.renderRow(rows[index], {\n                listIndex: index,\n                style: rowStyle,\n                getPrevRow: function getPrevRow() {\n                  return rows[index - 1] || null;\n                },\n                matchKeys: matchKeys,\n                swapFrom: swapFrom,\n                swapDepth: draggedDepth,\n                swapLength: swapLength\n              });\n            }\n          }, reactVirtualizedListProps));\n        });\n      } else {\n        // Render list without react-virtualized\n        list = rows.map(function (row, index) {\n          return _this5.renderRow(row, {\n            listIndex: index,\n            style: {\n              height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({\n                index: index,\n                treeIndex: index,\n                node: row.node,\n                path: row.path\n              })\n            },\n            getPrevRow: function getPrevRow() {\n              return rows[index - 1] || null;\n            },\n            matchKeys: matchKeys,\n            swapFrom: swapFrom,\n            swapDepth: draggedDepth,\n            swapLength: swapLength\n          });\n        });\n      }\n\n      return React.createElement(\"div\", {\n        className: classnames('rst__tree', className, rowDirectionClass),\n        style: containerStyle\n      }, list);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var instanceProps = prevState.instanceProps;\n      var newState = {};\n      var isTreeDataEqual = isEqual(instanceProps.treeData, nextProps.treeData); // make sure we have the most recent version of treeData\n\n      instanceProps.treeData = nextProps.treeData;\n\n      if (!isTreeDataEqual) {\n        if (instanceProps.ignoreOneTreeUpdate) {\n          instanceProps.ignoreOneTreeUpdate = false;\n        } else {\n          newState.searchFocusTreeIndex = null;\n          ReactSortableTree.loadLazyChildren(nextProps, prevState);\n          Object.assign(newState, ReactSortableTree.search(nextProps, prevState, false, false, false));\n        }\n\n        newState.draggingTreeData = null;\n        newState.draggedNode = null;\n        newState.draggedMinimumTreeIndex = null;\n        newState.draggedDepth = null;\n        newState.dragging = false;\n      } else if (!isEqual(instanceProps.searchQuery, nextProps.searchQuery)) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, false));\n      } else if (instanceProps.searchFocusOffset !== nextProps.searchFocusOffset) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, true));\n      }\n\n      instanceProps.searchQuery = nextProps.searchQuery;\n      instanceProps.searchFocusOffset = nextProps.searchFocusOffset;\n      newState.instanceProps = _objectSpread2(_objectSpread2({}, instanceProps), newState.instanceProps);\n      return newState;\n    }\n  }, {\n    key: \"search\",\n    value: function search(props, state, seekIndex, expand, singleSearch) {\n      var onChange = props.onChange,\n          getNodeKey = props.getNodeKey,\n          searchFinishCallback = props.searchFinishCallback,\n          searchQuery = props.searchQuery,\n          searchMethod = props.searchMethod,\n          searchFocusOffset = props.searchFocusOffset,\n          onlyExpandSearchedNodes = props.onlyExpandSearchedNodes;\n      var instanceProps = state.instanceProps; // Skip search if no conditions are specified\n\n      if (!searchQuery && !searchMethod) {\n        if (searchFinishCallback) {\n          searchFinishCallback([]);\n        }\n\n        return {\n          searchMatches: []\n        };\n      }\n\n      var newState = {\n        instanceProps: {}\n      }; // if onlyExpandSearchedNodes collapse the tree and search\n\n      var _find = find({\n        getNodeKey: getNodeKey,\n        treeData: onlyExpandSearchedNodes ? toggleExpandedForAll({\n          treeData: instanceProps.treeData,\n          expanded: false\n        }) : instanceProps.treeData,\n        searchQuery: searchQuery,\n        searchMethod: searchMethod || defaultSearchMethod,\n        searchFocusOffset: searchFocusOffset,\n        expandAllMatchPaths: expand && !singleSearch,\n        expandFocusMatchPaths: !!expand\n      }),\n          expandedTreeData = _find.treeData,\n          searchMatches = _find.matches; // Update the tree with data leaving all paths leading to matching nodes open\n\n\n      if (expand) {\n        newState.instanceProps.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\n        onChange(expandedTreeData);\n      }\n\n      if (searchFinishCallback) {\n        searchFinishCallback(searchMatches);\n      }\n\n      var searchFocusTreeIndex = null;\n\n      if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n        searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n      }\n\n      newState.searchMatches = searchMatches;\n      newState.searchFocusTreeIndex = searchFocusTreeIndex;\n      return newState;\n    }\n  }, {\n    key: \"loadLazyChildren\",\n    value: function loadLazyChildren(props, state) {\n      var instanceProps = state.instanceProps;\n      walk({\n        treeData: instanceProps.treeData,\n        getNodeKey: props.getNodeKey,\n        callback: function callback(_ref15) {\n          var node = _ref15.node,\n              path = _ref15.path,\n              lowerSiblingCounts = _ref15.lowerSiblingCounts,\n              treeIndex = _ref15.treeIndex; // If the node has children defined by a function, and is either expanded\n          //  or set to load even before expansion, run the function.\n\n          if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n            // Call the children fetching function\n            node.children({\n              node: node,\n              path: path,\n              lowerSiblingCounts: lowerSiblingCounts,\n              treeIndex: treeIndex,\n              // Provide a helper to append the new data when it is received\n              done: function done(childrenArray) {\n                return props.onChange(changeNodeAtPath({\n                  treeData: instanceProps.treeData,\n                  path: path,\n                  newNode: function newNode(_ref16) {\n                    var oldNode = _ref16.node;\n                    return (// Only replace the old node if it's the one we set off to find children\n                      //  for in the first place\n                      oldNode === node ? _objectSpread2(_objectSpread2({}, oldNode), {}, {\n                        children: childrenArray\n                      }) : oldNode\n                    );\n                  },\n                  getNodeKey: props.getNodeKey\n                }));\n              }\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReactSortableTree;\n}(Component);\n\nReactSortableTree.propTypes = {\n  dragDropManager: PropTypes.shape({\n    getMonitor: PropTypes.func\n  }).isRequired,\n  // Tree data in the following format:\n  // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n  // `title` is the primary label for the node\n  // `subtitle` is a secondary label for the node\n  // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n  // `children` is an array of child nodes belonging to the node.\n  treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\n  // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n  style: PropTypes.shape({}),\n  // Class name for the container wrapping the tree\n  className: PropTypes.string,\n  // Style applied to the inner, scrollable container (for padding, etc.)\n  innerStyle: PropTypes.shape({}),\n  // Used by react-virtualized\n  // Either a fixed row height (number) or a function that returns the\n  // height of a row given its index: `({ index: number }): number`\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  // Size in px of the region near the edges that initiates scrolling on dragover\n  slideRegionSize: PropTypes.number,\n  // Custom properties to hand to the react-virtualized list\n  // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n  reactVirtualizedListProps: PropTypes.shape({}),\n  // The width of the blocks containing the lines representing the structure of the tree.\n  scaffoldBlockPxWidth: PropTypes.number,\n  // Maximum depth nodes can be inserted at. Defaults to infinite.\n  maxDepth: PropTypes.number,\n  // The method used to search nodes.\n  // Defaults to a function that uses the `searchQuery` string to search for nodes with\n  // matching `title` or `subtitle` values.\n  // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n  searchMethod: PropTypes.func,\n  // Used by the `searchMethod` to highlight and scroll to matched nodes.\n  // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n  searchQuery: PropTypes.any,\n  // eslint-disable-line react/forbid-prop-types\n  // Outline the <`searchFocusOffset`>th node and scroll to it.\n  searchFocusOffset: PropTypes.number,\n  // Get the nodes that match the search criteria. Used for counting total matches, etc.\n  searchFinishCallback: PropTypes.func,\n  // Generate an object with additional props to be passed to the node renderer.\n  // Use this for adding buttons via the `buttons` key,\n  // or additional `style` / `className` settings.\n  generateNodeProps: PropTypes.func,\n  // Set to false to disable virtualization.\n  // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\n  isVirtualized: PropTypes.bool,\n  treeNodeRenderer: PropTypes.func,\n  // Override the default component for rendering nodes (but keep the scaffolding generator)\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n  nodeContentRenderer: PropTypes.func,\n  // Override the default component for rendering an empty tree\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `placeholder-renderer-default.js` to use as a base,\n  // and customize as needed.\n  placeholderRenderer: PropTypes.func,\n  theme: PropTypes.shape({\n    style: PropTypes.shape({}),\n    innerStyle: PropTypes.shape({}),\n    reactVirtualizedListProps: PropTypes.shape({}),\n    scaffoldBlockPxWidth: PropTypes.number,\n    slideRegionSize: PropTypes.number,\n    rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    treeNodeRenderer: PropTypes.func,\n    nodeContentRenderer: PropTypes.func,\n    placeholderRenderer: PropTypes.func\n  }),\n  // Determine the unique key used to identify each node and\n  // generate the `path` array passed in callbacks.\n  // By default, returns the index in the tree (omitting hidden nodes).\n  getNodeKey: PropTypes.func,\n  // Called whenever tree data changed.\n  // Just like with React input elements, you have to update your\n  // own component's data to see the changes reflected.\n  onChange: PropTypes.func.isRequired,\n  // Called after node move operation.\n  onMoveNode: PropTypes.func,\n  // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\n  canDrag: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Determine whether a node can be dropped based on its path and parents'.\n  canDrop: PropTypes.func,\n  // Determine whether a node can have children\n  canNodeHaveChildren: PropTypes.func,\n  // When true, or a callback returning true, dropping nodes to react-dnd\n  // drop targets outside of this tree will not remove them from this tree\n  shouldCopyOnOutsideDrop: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Called after children nodes collapsed or expanded.\n  onVisibilityToggle: PropTypes.func,\n  dndType: PropTypes.string,\n  // Called to track between dropped and dragging\n  onDragStateChanged: PropTypes.func,\n  // Specify that nodes that do not match search will be collapsed\n  onlyExpandSearchedNodes: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\nReactSortableTree.defaultProps = {\n  canDrag: true,\n  canDrop: null,\n  canNodeHaveChildren: function canNodeHaveChildren() {\n    return true;\n  },\n  className: '',\n  dndType: null,\n  generateNodeProps: null,\n  getNodeKey: defaultGetNodeKey,\n  innerStyle: {},\n  isVirtualized: true,\n  maxDepth: null,\n  treeNodeRenderer: null,\n  nodeContentRenderer: null,\n  onMoveNode: function onMoveNode() {},\n  onVisibilityToggle: function onVisibilityToggle() {},\n  placeholderRenderer: null,\n  reactVirtualizedListProps: {},\n  rowHeight: null,\n  scaffoldBlockPxWidth: null,\n  searchFinishCallback: null,\n  searchFocusOffset: null,\n  searchMethod: null,\n  searchQuery: null,\n  shouldCopyOnOutsideDrop: false,\n  slideRegionSize: null,\n  style: {},\n  theme: {},\n  onDragStateChanged: function onDragStateChanged() {},\n  onlyExpandSearchedNodes: false,\n  rowDirection: 'ltr'\n};\npolyfill(ReactSortableTree);\n\nvar SortableTreeWithoutDndContext = function SortableTreeWithoutDndContext(props) {\n  return React.createElement(DndContext.Consumer, null, function (_ref17) {\n    var dragDropManager = _ref17.dragDropManager;\n    return dragDropManager === undefined ? null : React.createElement(ReactSortableTree, _extends({}, props, {\n      dragDropManager: dragDropManager\n    }));\n  });\n};\n\nvar SortableTree = function SortableTree(props) {\n  return React.createElement(DndProvider, {\n    backend: HTML5Backend\n  }, React.createElement(SortableTreeWithoutDndContext, props));\n}; // Export the tree component without the react-dnd DragDropContext,\n\n\nexport default SortableTree;\nexport { SortableTreeWithoutDndContext, addNodeUnderParent, changeNodeAtPath, defaultGetNodeKey, defaultSearchMethod, find, getDepth, getDescendantCount, getFlatDataFromTree, getNodeAtPath, getTreeFromFlatData, getVisibleNodeCount, getVisibleNodeInfoAtIndex, insertNode, isDescendant, map, removeNode, removeNodeAtPath, toggleExpandedForAll, walk };","map":{"version":3,"sources":["/home/rafael/Documentos/britania/COM-front/node_modules/react-sortable-tree/dist/index.esm.js"],"names":["withScrolling","createScrollingComponent","createVerticalStrength","createHorizontalStrength","isEqual","PropTypes","React","Component","Children","cloneElement","DragSource","DropTarget","DndContext","DndProvider","HTML5Backend","List","AutoSizer","findDOMNode","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","value","_extends","assign","arguments","source","hasOwnProperty","call","apply","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","forEach","getOwnPropertyDescriptors","defineProperties","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_objectWithoutPropertiesLoose","excluded","sourceKeys","indexOf","_objectWithoutProperties","sourceSymbolKeys","propertyIsEnumerable","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","arr2","iter","toString","from","componentWillMount","state","getDerivedStateFromProps","undefined","setState","componentWillReceiveProps","nextProps","updater","prevState","bind","componentWillUpdate","nextState","prevProps","__reactInternalSnapshotFlag","__reactInternalSnapshot","getSnapshotBeforeUpdate","__suppressDeprecationWarning","polyfill","isReactComponent","Error","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","componentName","displayName","name","newApiName","componentDidUpdate","componentDidUpdatePolyfill","maybeSnapshot","snapshot","getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","treeIndex","children","expanded","nextIndex","childIndex","childCount","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","selfInfo","callbackResult","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","map","child","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","nextTreeIndex","_result","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","removeNode","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","nextTreeData","_ref16","getNodeAtPath","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","addNodeUnderParent","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","expandParent","_ref19$addAsFirstChil","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref20","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","_nextNode","parentPath","_childIndex","_insertedTreeIndex","insertIndex","_nextNode2","pathFragment","newChildren","insertNode","_ref22","depth","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","getFlatDataFromTree","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","getTreeFromFlatData","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","classnames","_len","classes","_key","Boolean","join","_createSuper","Derived","isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","e","Super","NewTarget","NodeRendererDefault","_Component","_super","render","_this$props","scaffoldBlockPxWidth","toggleChildrenVisibility","connectDragPreview","connectDragSource","isDragging","canDrop","canDrag","title","subtitle","draggedNode","isSearchMatch","isSearchFocus","buttons","className","style","didDrop","treeId","isOver","rowDirection","otherProps","nodeTitle","nodeSubtitle","rowDirectionClass","handle","createElement","_","dropEffect","isDraggedDescendant","isLandingPadActive","buttonStyle","left","right","height","type","onClick","width","opacity","btn","defaultProps","propTypes","shape","isRequired","oneOfType","func","arrayOf","string","number","bool","PlaceholderRendererDefault","_createSuper$1","TreeNode","listIndex","swapFrom","swapLength","swapDepth","connectDropTarget","getPrevRow","scaffoldBlockCount","scaffold","lowerSiblingCount","lineClass","highlightLineClass","_style","_createSuper$2","TreePlaceholder","drop","defaultGetNodeKey","getReactElementText","stringSearch","String","defaultSearchMethod","memoize","f","savedArgsArray","savedKeysArray","savedResult","args","keysArray","sort","argsArray","arg","memoizedInsertNode","memoizedGetFlatDataFromTree","memoizedGetDescendantCount","DndManager","treeRef","getTargetDepth","dropTargetProps","monitor","component","dropTargetDepth","rowAbove","aboveNodeCannotHaveChildren","canNodeHaveChildren","min","blocksOffset","dragSourceInitialDepth","getItem","relativePosition","getBoundingClientRect","leftShift","getSourceClientOffset","x","round","direction","getDifferenceFromInitialOffset","maxDepth","draggedChildDepth","abovePath","aboveNode","customCanDrop","_monitor$getItem","addedResult","prevPath","prevParent","prevTreeIndex","nextPath","nextParent","wrapSource","el","_this","nodeDragSource","beginDrag","startDrag","endDrag","getDropResult","dropTargetNode","nodeDragSourcePropInjection","connect","dragSource","dragPreview","dndType","wrapTarget","_this2","nodeDropTarget","hover","needsRedraw","cancelAnimationFrame","rafId","requestAnimationFrame","dragHover","nodeDropTargetPropInjection","dragged","dropTarget","wrapPlaceholder","_this3","placeholderDropTarget","_monitor$getItem2","placeholderPropInjection","get","draggingTreeData","slideRows","rows","fromIndex","toIndex","count","rowsWithoutMoved","_createSuper$3","treeIdCounter","mergeTheme","merged","theme","innerStyle","reactVirtualizedListProps","overridableDefaults","nodeContentRenderer","placeholderRenderer","rowHeight","slideRegionSize","treeNodeRenderer","propKey","ReactSortableTree","_mergeTheme","isVirtualized","dndManager","treePlaceholderRenderer","scrollZoneVirtualList","vStrength","hStrength","draggedMinimumTreeIndex","draggedDepth","searchMatches","searchFocusTreeIndex","dragging","instanceProps","ignoreOneTreeUpdate","moveNode","handleDndMonitorChange","componentDidMount","loadLazyChildren","stateUpdate","search","clearMonitorSubscription","dragDropManager","getMonitor","subscribeToStateChange","onDragStateChanged","componentWillUnmount","getRows","targetNode","onChange","onVisibilityToggle","_insertNode","nextParentNode","onMoveNode","_removeNode","newDraggingTreeData","expandedParentPath","dropResult","_this4","resetTree","shouldCopy","shouldCopyOnOutsideDrop","copyNode","renderRow","row","matchKeys","_mergeTheme2","generateNodeProps","TreeNodeRenderer","NodeContentRenderer","nodeKey","callbackParams","nodeProps","rowCanDrag","sharedProps","_this5","_mergeTheme3","_this$state","swapTo","scrollToInfo","scrollToIndex","containerStyle","list","Placeholder","PlaceholderContent","ScrollZoneVirtualList","verticalStrength","horizontalStrength","speed","scrollToAlignment","onScroll","scrollTop","rowCount","estimatedRowSize","rowRenderer","rowStyle","newState","isTreeDataEqual","seekIndex","expand","singleSearch","searchFinishCallback","onlyExpandSearchedNodes","_find","expandedTreeData","loadCollapsedLazyChildren","done","childrenArray","oldNode","any","SortableTreeWithoutDndContext","Consumer","SortableTree","backend"],"mappings":"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","sourcesContent":["import withScrolling, { createScrollingComponent, createVerticalStrength, createHorizontalStrength } from 'frontend-collective-react-dnd-scrollzone';\nimport isEqual from 'lodash.isequal';\nimport PropTypes from 'prop-types';\nimport React, { Component, Children, cloneElement } from 'react';\nimport { DragSource, DropTarget, DndContext, DndProvider } from 'react-dnd';\nimport { HTML5Backend } from 'react-dnd-html5-backend';\nimport { List, AutoSizer } from 'react-virtualized';\nimport { findDOMNode } from 'react-dom';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  }\n  // Binding \"this\" is important for shallow renderer support.\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(\n      prevProps,\n      prevState\n    );\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n}\n\n// React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component) {\n  var prototype = Component.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (\n    typeof Component.getDerivedStateFromProps !== 'function' &&\n    typeof prototype.getSnapshotBeforeUpdate !== 'function'\n  ) {\n    return Component;\n  }\n\n  // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n  if (\n    foundWillMountName !== null ||\n    foundWillReceivePropsName !== null ||\n    foundWillUpdateName !== null\n  ) {\n    var componentName = Component.displayName || Component.name;\n    var newApiName =\n      typeof Component.getDerivedStateFromProps === 'function'\n        ? 'getDerivedStateFromProps()'\n        : 'getSnapshotBeforeUpdate()';\n\n    throw Error(\n      'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n        componentName +\n        ' uses ' +\n        newApiName +\n        ' but also contains the following legacy lifecycles:' +\n        (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') +\n        (foundWillReceivePropsName !== null\n          ? '\\n  ' + foundWillReceivePropsName\n          : '') +\n        (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') +\n        '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' +\n        'https://fb.me/react-async-component-lifecycle-hooks'\n    );\n  }\n\n  // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  }\n\n  // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error(\n        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'\n      );\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(\n      prevProps,\n      prevState,\n      maybeSnapshot\n    ) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag\n        ? this.__reactInternalSnapshot\n        : maybeSnapshot;\n\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component;\n}\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n  var targetIndex = _ref.targetIndex,\n      node = _ref.node,\n      currentIndex = _ref.currentIndex,\n      getNodeKey = _ref.getNodeKey,\n      _ref$path = _ref.path,\n      path = _ref$path === void 0 ? [] : _ref$path,\n      _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n      lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,\n      _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n      ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,\n      _ref$isPseudoRoot = _ref.isPseudoRoot,\n      isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot;\n  // The pseudo-root is not considered in the path\n  var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]) : []; // Return target node when found\n\n  if (currentIndex === targetIndex) {\n    return {\n      node: node,\n      lowerSiblingCounts: lowerSiblingCounts,\n      path: selfPath\n    };\n  } // Add one and continue for nodes with no children or hidden children\n\n\n  if (!node.children || ignoreCollapsed && node.expanded !== true) {\n    return {\n      nextIndex: currentIndex + 1\n    };\n  } // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n\n\n  var childIndex = currentIndex + 1;\n  var childCount = node.children.length;\n\n  for (var i = 0; i < childCount; i += 1) {\n    var result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed: ignoreCollapsed,\n      getNodeKey: getNodeKey,\n      targetIndex: targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  } // If the target node is not found, return the farthest traversed index\n\n\n  return {\n    nextIndex: childIndex\n  };\n}\n\nfunction getDescendantCount(_ref2) {\n  var node = _ref2.node,\n      _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n      ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;\n  return getNodeDataAtTreeIndexOrNextIndex({\n    getNodeKey: function getNodeKey() {},\n    ignoreCollapsed: ignoreCollapsed,\n    node: node,\n    currentIndex: 0,\n    targetIndex: -1\n  }).nextIndex - 1;\n}\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\nfunction walkDescendants(_ref3) {\n  var callback = _ref3.callback,\n      getNodeKey = _ref3.getNodeKey,\n      ignoreCollapsed = _ref3.ignoreCollapsed,\n      _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n      isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,\n      node = _ref3.node,\n      _ref3$parentNode = _ref3.parentNode,\n      parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,\n      currentIndex = _ref3.currentIndex,\n      _ref3$path = _ref3.path,\n      path = _ref3$path === void 0 ? [] : _ref3$path,\n      _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n      lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou;\n  // The pseudo-root is not considered in the path\n  var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = isPseudoRoot ? null : {\n    node: node,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  if (!isPseudoRoot) {\n    var callbackResult = callback(selfInfo); // Cut walk short if the callback returned false\n\n    if (callbackResult === false) {\n      return false;\n    }\n  } // Return self on nodes with no children or hidden children\n\n\n  if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return currentIndex;\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = node.children.length;\n\n  if (typeof node.children !== 'function') {\n    for (var i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n        path: selfPath\n      }); // Cut walk short if the callback returned false\n\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction mapDescendants(_ref4) {\n  var callback = _ref4.callback,\n      getNodeKey = _ref4.getNodeKey,\n      ignoreCollapsed = _ref4.ignoreCollapsed,\n      _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n      isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,\n      node = _ref4.node,\n      _ref4$parentNode = _ref4.parentNode,\n      parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,\n      currentIndex = _ref4.currentIndex,\n      _ref4$path = _ref4.path,\n      path = _ref4$path === void 0 ? [] : _ref4$path,\n      _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n      lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;\n\n  var nextNode = _objectSpread2({}, node); // The pseudo-root is not considered in the path\n\n\n  var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n    node: nextNode,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = {\n    node: nextNode,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  }; // Return self on nodes with no children or hidden children\n\n  if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = nextNode.children.length;\n\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map(function (child, i) {\n      var mapResult = mapDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\n\n\nfunction getVisibleNodeCount(_ref5) {\n  var treeData = _ref5.treeData;\n\n  var traverse = function traverse(node) {\n    if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n      return 1;\n    }\n\n    return 1 + node.children.reduce(function (total, currentNode) {\n      return total + traverse(currentNode);\n    }, 0);\n  };\n\n  return treeData.reduce(function (total, currentNode) {\n    return total + traverse(currentNode);\n  }, 0);\n}\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\n\nfunction getVisibleNodeInfoAtIndex(_ref6) {\n  var treeData = _ref6.treeData,\n      targetIndex = _ref6.index,\n      getNodeKey = _ref6.getNodeKey;\n\n  if (!treeData || treeData.length < 1) {\n    return null;\n  } // Call the tree traversal with a pseudo-root node\n\n\n  var result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex: targetIndex,\n    getNodeKey: getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\n\nfunction walk(_ref7) {\n  var treeData = _ref7.treeData,\n      getNodeKey = _ref7.getNodeKey,\n      callback = _ref7.callback,\n      _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n      ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nfunction map(_ref8) {\n  var treeData = _ref8.treeData,\n      getNodeKey = _ref8.getNodeKey,\n      callback = _ref8.callback,\n      _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n      ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nfunction toggleExpandedForAll(_ref9) {\n  var treeData = _ref9.treeData,\n      _ref9$expanded = _ref9.expanded,\n      expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;\n  return map({\n    treeData: treeData,\n    callback: function callback(_ref10) {\n      var node = _ref10.node;\n      return _objectSpread2(_objectSpread2({}, node), {}, {\n        expanded: expanded\n      });\n    },\n    getNodeKey: function getNodeKey(_ref11) {\n      var treeIndex = _ref11.treeIndex;\n      return treeIndex;\n    },\n    ignoreCollapsed: false\n  });\n}\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nfunction changeNodeAtPath(_ref12) {\n  var treeData = _ref12.treeData,\n      path = _ref12.path,\n      newNode = _ref12.newNode,\n      getNodeKey = _ref12.getNodeKey,\n      _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n      ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;\n  var RESULT_MISS = 'RESULT_MISS';\n\n  var traverse = function traverse(_ref13) {\n    var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n        isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,\n        node = _ref13.node,\n        currentTreeIndex = _ref13.currentTreeIndex,\n        pathIndex = _ref13.pathIndex;\n\n    if (!isPseudoRoot && getNodeKey({\n      node: node,\n      treeIndex: currentTreeIndex\n    }) !== path[pathIndex]) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function' ? newNode({\n        node: node,\n        treeIndex: currentTreeIndex\n      }) : newNode;\n    }\n\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.');\n    }\n\n    var nextTreeIndex = currentTreeIndex + 1;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      var _result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      }); // If the result went down the correct path\n\n\n      if (_result !== RESULT_MISS) {\n        if (_result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return _objectSpread2(_objectSpread2({}, node), {}, {\n            children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))\n          });\n        } // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n\n\n        return _objectSpread2(_objectSpread2({}, node), {}, {\n          children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))\n        });\n      }\n\n      nextTreeIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    }\n\n    return RESULT_MISS;\n  }; // Use a pseudo-root node in the beginning traversal\n\n\n  var result = traverse({\n    node: {\n      children: treeData\n    },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.');\n  }\n\n  return result.children;\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\n\nfunction removeNodeAtPath(_ref14) {\n  var treeData = _ref14.treeData,\n      path = _ref14.path,\n      getNodeKey = _ref14.getNodeKey,\n      _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n      ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;\n  return changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: null // Delete the node\n\n  });\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\n\nfunction removeNode(_ref15) {\n  var treeData = _ref15.treeData,\n      path = _ref15.path,\n      getNodeKey = _ref15.getNodeKey,\n      _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n      ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;\n  var removedNode = null;\n  var removedTreeIndex = null;\n  var nextTreeData = changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: function newNode(_ref16) {\n      var node = _ref16.node,\n          treeIndex = _ref16.treeIndex;\n      // Store the target node and delete it from the tree\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n      return null;\n    }\n  });\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\n\nfunction getNodeAtPath(_ref17) {\n  var treeData = _ref17.treeData,\n      path = _ref17.path,\n      getNodeKey = _ref17.getNodeKey,\n      _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n      ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;\n  var foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData: treeData,\n      path: path,\n      getNodeKey: getNodeKey,\n      ignoreCollapsed: ignoreCollapsed,\n      newNode: function newNode(_ref18) {\n        var node = _ref18.node,\n            treeIndex = _ref18.treeIndex;\n        foundNodeInfo = {\n          node: node,\n          treeIndex: treeIndex\n        };\n        return node;\n      }\n    });\n  } catch (err) {// Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\n\nfunction addNodeUnderParent(_ref19) {\n  var treeData = _ref19.treeData,\n      newNode = _ref19.newNode,\n      _ref19$parentKey = _ref19.parentKey,\n      parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,\n      getNodeKey = _ref19.getNodeKey,\n      _ref19$ignoreCollapse = _ref19.ignoreCollapsed,\n      ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,\n      _ref19$expandParent = _ref19.expandParent,\n      expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,\n      _ref19$addAsFirstChil = _ref19.addAsFirstChild,\n      addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;\n\n  if (parentKey === null) {\n    return addAsFirstChild ? {\n      treeData: [newNode].concat(_toConsumableArray(treeData || [])),\n      treeIndex: 0\n    } : {\n      treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  var insertedTreeIndex = null;\n  var hasBeenAdded = false;\n  var changedTreeData = map({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(_ref20) {\n      var node = _ref20.node,\n          treeIndex = _ref20.treeIndex,\n          path = _ref20.path;\n      var key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is\n\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n\n      hasBeenAdded = true;\n\n      var parentNode = _objectSpread2({}, node);\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      } // If no children exist yet, just add the single newNode\n\n\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return _objectSpread2(_objectSpread2({}, parentNode), {}, {\n          children: [newNode]\n        });\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function');\n      }\n\n      var nextTreeIndex = treeIndex + 1;\n\n      for (var i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex += 1 + getDescendantCount({\n          node: parentNode.children[i],\n          ignoreCollapsed: ignoreCollapsed\n        });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n      var children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : [].concat(_toConsumableArray(parentNode.children), [newNode]);\n      return _objectSpread2(_objectSpread2({}, parentNode), {}, {\n        children: children\n      });\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.');\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex(_ref21) {\n  var targetDepth = _ref21.targetDepth,\n      minimumTreeIndex = _ref21.minimumTreeIndex,\n      newNode = _ref21.newNode,\n      ignoreCollapsed = _ref21.ignoreCollapsed,\n      expandParent = _ref21.expandParent,\n      _ref21$isPseudoRoot = _ref21.isPseudoRoot,\n      isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,\n      isLastChild = _ref21.isLastChild,\n      node = _ref21.node,\n      currentIndex = _ref21.currentIndex,\n      currentDepth = _ref21.currentDepth,\n      getNodeKey = _ref21.getNodeKey,\n      _ref21$path = _ref21.path,\n      path = _ref21$path === void 0 ? [] : _ref21$path;\n\n  var selfPath = function selfPath(n) {\n    return isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n      node: n,\n      treeIndex: currentIndex\n    })]);\n  }; // If the current position is the only possible place to add, add it\n\n\n  if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function');\n    } else {\n      var extraNodeProps = expandParent ? {\n        expanded: true\n      } : {};\n\n      var _nextNode = _objectSpread2(_objectSpread2(_objectSpread2({}, node), extraNodeProps), {}, {\n        children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n      });\n\n      return {\n        node: _nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(_nextNode),\n        parentNode: isPseudoRoot ? null : _nextNode\n      };\n    }\n  } // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n\n\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n      return {\n        node: node,\n        nextIndex: currentIndex + 1\n      };\n    } // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n\n\n    var _childIndex = currentIndex + 1;\n\n    var _insertedTreeIndex = null;\n    var insertIndex = null;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (_childIndex >= minimumTreeIndex) {\n        _insertedTreeIndex = _childIndex;\n        insertIndex = i;\n        break;\n      } // Increment the index by the child itself plus the number of descendants it has\n\n\n      _childIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    } // If no valid indices to add the node were found\n\n\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (_childIndex < minimumTreeIndex && !isLastChild) {\n        return {\n          node: node,\n          nextIndex: _childIndex\n        };\n      } // Use the last position in the children array to insert the newNode\n\n\n      _insertedTreeIndex = _childIndex;\n      insertIndex = node.children.length;\n    } // Insert the newNode at the insertIndex\n\n\n    var _nextNode2 = _objectSpread2(_objectSpread2({}, node), {}, {\n      children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))\n    }); // Return node with successful insert result\n\n\n    return {\n      node: _nextNode2,\n      nextIndex: _childIndex,\n      insertedTreeIndex: _insertedTreeIndex,\n      parentPath: selfPath(_nextNode2),\n      parentNode: isPseudoRoot ? null : _nextNode2\n    };\n  } // Skip over nodes with no children or hidden children\n\n\n  if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      node: node,\n      nextIndex: currentIndex + 1\n    };\n  } // Get all descendants\n\n\n  var insertedTreeIndex = null;\n  var pathFragment = null;\n  var parentNode = null;\n  var childIndex = currentIndex + 1;\n  var newChildren = node.children;\n\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map(function (child, i) {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      var mapResult = addNodeAtDepthAndIndex({\n        targetDepth: targetDepth,\n        minimumTreeIndex: minimumTreeIndex,\n        newNode: newNode,\n        ignoreCollapsed: ignoreCollapsed,\n        expandParent: expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey: getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n\n      });\n\n      if ('insertedTreeIndex' in mapResult) {\n        insertedTreeIndex = mapResult.insertedTreeIndex;\n        parentNode = mapResult.parentNode;\n        pathFragment = mapResult.parentPath;\n      }\n\n      childIndex = mapResult.nextIndex;\n      return mapResult.node;\n    });\n  }\n\n  var nextNode = _objectSpread2(_objectSpread2({}, node), {}, {\n    children: newChildren\n  });\n\n  var result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = [].concat(_toConsumableArray(selfPath(nextNode)), _toConsumableArray(pathFragment));\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\n\n\nfunction insertNode(_ref22) {\n  var treeData = _ref22.treeData,\n      targetDepth = _ref22.depth,\n      minimumTreeIndex = _ref22.minimumTreeIndex,\n      newNode = _ref22.newNode,\n      _ref22$getNodeKey = _ref22.getNodeKey,\n      getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,\n      _ref22$ignoreCollapse = _ref22.ignoreCollapsed,\n      ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,\n      _ref22$expandParent = _ref22.expandParent,\n      expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;\n\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({\n        node: newNode,\n        treeIndex: 0\n      })],\n      parentNode: null\n    };\n  }\n\n  var insertResult = addNodeAtDepthAndIndex({\n    targetDepth: targetDepth,\n    minimumTreeIndex: minimumTreeIndex,\n    newNode: newNode,\n    ignoreCollapsed: ignoreCollapsed,\n    expandParent: expandParent,\n    getNodeKey: getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.');\n  }\n\n  var treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex: treeIndex,\n    path: [].concat(_toConsumableArray(insertResult.parentPath), [getNodeKey({\n      node: newNode,\n      treeIndex: treeIndex\n    })]),\n    parentNode: insertResult.parentNode\n  };\n}\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\n\nfunction getFlatDataFromTree(_ref23) {\n  var treeData = _ref23.treeData,\n      getNodeKey = _ref23.getNodeKey,\n      _ref23$ignoreCollapse = _ref23.ignoreCollapsed,\n      ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  var flattened = [];\n  walk({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(nodeInfo) {\n      flattened.push(nodeInfo);\n    }\n  });\n  return flattened;\n}\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\n\nfunction getTreeFromFlatData(_ref24) {\n  var flatData = _ref24.flatData,\n      _ref24$getKey = _ref24.getKey,\n      getKey = _ref24$getKey === void 0 ? function (node) {\n    return node.id;\n  } : _ref24$getKey,\n      _ref24$getParentKey = _ref24.getParentKey,\n      getParentKey = _ref24$getParentKey === void 0 ? function (node) {\n    return node.parentId;\n  } : _ref24$getParentKey,\n      _ref24$rootKey = _ref24.rootKey,\n      rootKey = _ref24$rootKey === void 0 ? '0' : _ref24$rootKey;\n\n  if (!flatData) {\n    return [];\n  }\n\n  var childrenToParents = {};\n  flatData.forEach(function (child) {\n    var parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  var trav = function trav(parent) {\n    var parentKey = getKey(parent);\n\n    if (parentKey in childrenToParents) {\n      return _objectSpread2(_objectSpread2({}, parent), {}, {\n        children: childrenToParents[parentKey].map(function (child) {\n          return trav(child);\n        })\n      });\n    }\n\n    return _objectSpread2({}, parent);\n  };\n\n  return childrenToParents[rootKey].map(function (child) {\n    return trav(child);\n  });\n}\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\n\nfunction isDescendant(older, younger) {\n  return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n    return child === younger || isDescendant(child, younger);\n  });\n}\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\n\nfunction getDepth(node) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1;\n  }\n\n  return node.children.reduce(function (deepest, child) {\n    return Math.max(deepest, getDepth(child, depth + 1));\n  }, depth);\n}\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\n\nfunction find(_ref25) {\n  var getNodeKey = _ref25.getNodeKey,\n      treeData = _ref25.treeData,\n      searchQuery = _ref25.searchQuery,\n      searchMethod = _ref25.searchMethod,\n      searchFocusOffset = _ref25.searchFocusOffset,\n      _ref25$expandAllMatch = _ref25.expandAllMatchPaths,\n      expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,\n      _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,\n      expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;\n  var matchCount = 0;\n\n  var trav = function trav(_ref26) {\n    var _ref26$isPseudoRoot = _ref26.isPseudoRoot,\n        isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,\n        node = _ref26.node,\n        currentIndex = _ref26.currentIndex,\n        _ref26$path = _ref26.path,\n        path = _ref26$path === void 0 ? [] : _ref26$path;\n    var matches = [];\n    var isSelfMatch = false;\n    var hasFocusMatch = false; // The pseudo-root is not considered in the path\n\n    var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({\n      node: node,\n      treeIndex: currentIndex\n    })]);\n    var extraInfo = isPseudoRoot ? null : {\n      path: selfPath,\n      treeIndex: currentIndex\n    }; // Nodes with with children that aren't lazy\n\n    var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0; // Examine the current node to see if it is a match\n\n    if (!isPseudoRoot && searchMethod(_objectSpread2(_objectSpread2({}, extraInfo), {}, {\n      node: node,\n      searchQuery: searchQuery\n    }))) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      } // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n\n\n      matchCount += 1; // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n\n      isSelfMatch = true;\n    }\n\n    var childIndex = currentIndex;\n\n    var newNode = _objectSpread2({}, node);\n\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(function (child) {\n        var mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));\n\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          } // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n\n\n          if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    } // Cannot assign a treeIndex to hidden nodes\n\n\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(function (match) {\n        return _objectSpread2(_objectSpread2({}, match), {}, {\n          treeIndex: null\n        });\n      });\n    } // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n\n\n    if (isSelfMatch) {\n      matches = [_objectSpread2(_objectSpread2({}, extraInfo), {}, {\n        node: newNode\n      })].concat(_toConsumableArray(matches));\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches: matches,\n      hasFocusMatch: hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  var result = trav({\n    node: {\n      children: treeData\n    },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\n// very simple className utility for creating a classname string...\n// Falsy arguments are ignored:\n//\n// const active = true\n// const className = classnames(\n//    \"class1\",\n//    !active && \"class2\",\n//    active && \"class3\"\n// ); // returns -> class1 class3\";\n//\nfunction classnames() {\n  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n    classes[_key] = arguments[_key];\n  }\n\n  // Use Boolean constructor as a filter callback\n  // Allows for loose type truthy/falsey checks\n  // Boolean(\"\") === false;\n  // Boolean(false) === false;\n  // Boolean(undefined) === false;\n  // Boolean(null) === false;\n  // Boolean(0) === false;\n  // Boolean(\"classname\") === true;\n  return classes.filter(Boolean).join(' ');\n}\n\nfunction _createSuper(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar NodeRendererDefault =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(NodeRendererDefault, _Component);\n\n  var _super = _createSuper(NodeRendererDefault);\n\n  function NodeRendererDefault() {\n    _classCallCheck(this, NodeRendererDefault);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NodeRendererDefault, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          toggleChildrenVisibility = _this$props.toggleChildrenVisibility,\n          connectDragPreview = _this$props.connectDragPreview,\n          connectDragSource = _this$props.connectDragSource,\n          isDragging = _this$props.isDragging,\n          canDrop = _this$props.canDrop,\n          canDrag = _this$props.canDrag,\n          node = _this$props.node,\n          title = _this$props.title,\n          subtitle = _this$props.subtitle,\n          draggedNode = _this$props.draggedNode,\n          path = _this$props.path,\n          treeIndex = _this$props.treeIndex,\n          isSearchMatch = _this$props.isSearchMatch,\n          isSearchFocus = _this$props.isSearchFocus,\n          buttons = _this$props.buttons,\n          className = _this$props.className,\n          style = _this$props.style,\n          didDrop = _this$props.didDrop,\n          treeId = _this$props.treeId,\n          isOver = _this$props.isOver,\n          parentNode = _this$props.parentNode,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"scaffoldBlockPxWidth\", \"toggleChildrenVisibility\", \"connectDragPreview\", \"connectDragSource\", \"isDragging\", \"canDrop\", \"canDrag\", \"node\", \"title\", \"subtitle\", \"draggedNode\", \"path\", \"treeIndex\", \"isSearchMatch\", \"isSearchFocus\", \"buttons\", \"className\", \"style\", \"didDrop\", \"treeId\", \"isOver\", \"parentNode\", \"rowDirection\"]);\n\n      var nodeTitle = title || node.title;\n      var nodeSubtitle = subtitle || node.subtitle;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var handle;\n\n      if (canDrag) {\n        if (typeof node.children === 'function' && node.expanded) {\n          // Show a loading symbol on the handle when the children are expanded\n          //  and yet still defined by a function (a callback to fetch the children)\n          handle = React.createElement(\"div\", {\n            className: \"rst__loadingHandle\"\n          }, React.createElement(\"div\", {\n            className: \"rst__loadingCircle\"\n          }, _toConsumableArray(new Array(12)).map(function (_, index) {\n            return React.createElement(\"div\", {\n              // eslint-disable-next-line react/no-array-index-key\n              key: index,\n              className: classnames('rst__loadingCirclePoint', rowDirectionClass)\n            });\n          })));\n        } else {\n          // Show the handle used to initiate a drag-and-drop\n          handle = connectDragSource(React.createElement(\"div\", {\n            className: \"rst__moveHandle\"\n          }), {\n            dropEffect: 'copy'\n          });\n        }\n      }\n\n      var isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\n      var isLandingPadActive = !didDrop && isDragging;\n      var buttonStyle = {\n        left: -0.5 * scaffoldBlockPxWidth\n      };\n\n      if (rowDirection === 'rtl') {\n        buttonStyle = {\n          right: -0.5 * scaffoldBlockPxWidth\n        };\n      }\n\n      return React.createElement(\"div\", _extends({\n        style: {\n          height: '100%'\n        }\n      }, otherProps), toggleChildrenVisibility && node.children && (node.children.length > 0 || typeof node.children === 'function') && React.createElement(\"div\", null, React.createElement(\"button\", {\n        type: \"button\",\n        \"aria-label\": node.expanded ? 'Collapse' : 'Expand',\n        className: classnames(node.expanded ? 'rst__collapseButton' : 'rst__expandButton', rowDirectionClass),\n        style: buttonStyle,\n        onClick: function onClick() {\n          return toggleChildrenVisibility({\n            node: node,\n            path: path,\n            treeIndex: treeIndex\n          });\n        }\n      }), node.expanded && !isDragging && React.createElement(\"div\", {\n        style: {\n          width: scaffoldBlockPxWidth\n        },\n        className: classnames('rst__lineChildren', rowDirectionClass)\n      })), React.createElement(\"div\", {\n        className: classnames('rst__rowWrapper', rowDirectionClass)\n      }, connectDragPreview(React.createElement(\"div\", {\n        className: classnames('rst__row', isLandingPadActive && 'rst__rowLandingPad', isLandingPadActive && !canDrop && 'rst__rowCancelPad', isSearchMatch && 'rst__rowSearchMatch', isSearchFocus && 'rst__rowSearchFocus', rowDirectionClass, className),\n        style: _objectSpread2({\n          opacity: isDraggedDescendant ? 0.5 : 1\n        }, style)\n      }, handle, React.createElement(\"div\", {\n        className: classnames('rst__rowContents', !canDrag && 'rst__rowContentsDragDisabled', rowDirectionClass)\n      }, React.createElement(\"div\", {\n        className: classnames('rst__rowLabel', rowDirectionClass)\n      }, React.createElement(\"span\", {\n        className: classnames('rst__rowTitle', node.subtitle && 'rst__rowTitleWithSubtitle')\n      }, typeof nodeTitle === 'function' ? nodeTitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeTitle), nodeSubtitle && React.createElement(\"span\", {\n        className: \"rst__rowSubtitle\"\n      }, typeof nodeSubtitle === 'function' ? nodeSubtitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeSubtitle)), React.createElement(\"div\", {\n        className: \"rst__rowToolbar\"\n      }, buttons.map(function (btn, index) {\n        return React.createElement(\"div\", {\n          key: index // eslint-disable-line react/no-array-index-key\n          ,\n          className: \"rst__toolbarButton\"\n        }, btn);\n      })))))));\n    }\n  }]);\n\n  return NodeRendererDefault;\n}(Component);\n\nNodeRendererDefault.defaultProps = {\n  isSearchMatch: false,\n  isSearchFocus: false,\n  canDrag: false,\n  toggleChildrenVisibility: null,\n  buttons: [],\n  className: '',\n  style: {},\n  parentNode: null,\n  draggedNode: null,\n  canDrop: false,\n  title: null,\n  subtitle: null,\n  rowDirection: 'ltr'\n};\nNodeRendererDefault.propTypes = {\n  node: PropTypes.shape({}).isRequired,\n  title: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  subtitle: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  isSearchMatch: PropTypes.bool,\n  isSearchFocus: PropTypes.bool,\n  canDrag: PropTypes.bool,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  toggleChildrenVisibility: PropTypes.func,\n  buttons: PropTypes.arrayOf(PropTypes.node),\n  className: PropTypes.string,\n  style: PropTypes.shape({}),\n  // Drag and drop API functions\n  // Drag source\n  connectDragPreview: PropTypes.func.isRequired,\n  connectDragSource: PropTypes.func.isRequired,\n  parentNode: PropTypes.shape({}),\n  // Needed for dndManager\n  isDragging: PropTypes.bool.isRequired,\n  didDrop: PropTypes.bool.isRequired,\n  draggedNode: PropTypes.shape({}),\n  // Drop target\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nvar PlaceholderRendererDefault = function PlaceholderRendererDefault(_ref) {\n  var isOver = _ref.isOver,\n      canDrop = _ref.canDrop;\n  return React.createElement(\"div\", {\n    className: classnames('rst__placeholder', canDrop && 'rst__placeholderLandingPad', canDrop && !isOver && 'rst__placeholderCancelPad')\n  });\n};\n\nPlaceholderRendererDefault.defaultProps = {\n  isOver: false,\n  canDrop: false\n};\nPlaceholderRendererDefault.propTypes = {\n  isOver: PropTypes.bool,\n  canDrop: PropTypes.bool\n};\n\nfunction _createSuper$1(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar TreeNode =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TreeNode, _Component);\n\n  var _super = _createSuper$1(TreeNode);\n\n  function TreeNode() {\n    _classCallCheck(this, TreeNode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TreeNode, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          listIndex = _this$props.listIndex,\n          swapFrom = _this$props.swapFrom,\n          swapLength = _this$props.swapLength,\n          swapDepth = _this$props.swapDepth,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          lowerSiblingCounts = _this$props.lowerSiblingCounts,\n          connectDropTarget = _this$props.connectDropTarget,\n          isOver = _this$props.isOver,\n          draggedNode = _this$props.draggedNode,\n          canDrop = _this$props.canDrop,\n          treeIndex = _this$props.treeIndex,\n          treeId = _this$props.treeId,\n          getPrevRow = _this$props.getPrevRow,\n          node = _this$props.node,\n          path = _this$props.path,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"listIndex\", \"swapFrom\", \"swapLength\", \"swapDepth\", \"scaffoldBlockPxWidth\", \"lowerSiblingCounts\", \"connectDropTarget\", \"isOver\", \"draggedNode\", \"canDrop\", \"treeIndex\", \"treeId\", \"getPrevRow\", \"node\", \"path\", \"rowDirection\"]);\n\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null; // Construct the scaffold representing the structure of the tree\n\n      var scaffoldBlockCount = lowerSiblingCounts.length;\n      var scaffold = [];\n      lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n        var lineClass = '';\n\n        if (lowerSiblingCount > 0) {\n          // At this level in the tree, the nodes had sibling nodes further down\n          if (listIndex === 0) {\n            // Top-left corner of the tree\n            // +-----+\n            // |     |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineHalfVerticalBottom';\n          } else if (i === scaffoldBlockCount - 1) {\n            // Last scaffold block in the row, right before the row content\n            // +--+--+\n            // |  |  |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineFullVertical';\n          } else {\n            // Simply connecting the line extending down to the next sibling on this level\n            // +--+--+\n            // |  |  |\n            // |  |  |\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineFullVertical';\n          }\n        } else if (listIndex === 0) {\n          // Top-left corner of the tree, but has no siblings\n          // +-----+\n          // |     |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfHorizontalRight';\n        } else if (i === scaffoldBlockCount - 1) {\n          // The last or only node in this level of the tree\n          // +--+--+\n          // |  |  |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfVerticalTop rst__lineHalfHorizontalRight';\n        }\n\n        scaffold.push(React.createElement(\"div\", {\n          key: \"pre_\".concat(1 + i),\n          style: {\n            width: scaffoldBlockPxWidth\n          },\n          className: classnames('rst__lineBlock', lineClass, rowDirectionClass)\n        }));\n\n        if (treeIndex !== listIndex && i === swapDepth) {\n          // This row has been shifted, and is at the depth of\n          // the line pointing to the new destination\n          var highlightLineClass = '';\n\n          if (listIndex === swapFrom + swapLength - 1) {\n            // This block is on the bottom (target) line\n            // This block points at the target block (where the row will go when released)\n            highlightLineClass = 'rst__highlightBottomLeftCorner';\n          } else if (treeIndex === swapFrom) {\n            // This block is on the top (source) line\n            highlightLineClass = 'rst__highlightTopLeftCorner';\n          } else {\n            // This block is between the bottom and top\n            highlightLineClass = 'rst__highlightLineVertical';\n          }\n\n          var _style;\n\n          if (rowDirection === 'rtl') {\n            _style = {\n              width: scaffoldBlockPxWidth,\n              right: scaffoldBlockPxWidth * i\n            };\n          } else {\n            // Default ltr\n            _style = {\n              width: scaffoldBlockPxWidth,\n              left: scaffoldBlockPxWidth * i\n            };\n          }\n\n          scaffold.push(React.createElement(\"div\", {\n            // eslint-disable-next-line react/no-array-index-key\n            key: i,\n            style: _style,\n            className: classnames('rst__absoluteLineBlock', highlightLineClass, rowDirectionClass)\n          }));\n        }\n      });\n      var style;\n\n      if (rowDirection === 'rtl') {\n        style = {\n          right: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      } else {\n        // Default ltr\n        style = {\n          left: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      }\n\n      return connectDropTarget(React.createElement(\"div\", _extends({}, otherProps, {\n        className: classnames('rst__node', rowDirectionClass)\n      }), scaffold, React.createElement(\"div\", {\n        className: \"rst__nodeContent\",\n        style: style\n      }, Children.map(children, function (child) {\n        return cloneElement(child, {\n          isOver: isOver,\n          canDrop: canDrop,\n          draggedNode: draggedNode\n        });\n      }))));\n    }\n  }]);\n\n  return TreeNode;\n}(Component);\n\nTreeNode.defaultProps = {\n  swapFrom: null,\n  swapDepth: null,\n  swapLength: null,\n  canDrop: false,\n  draggedNode: null,\n  rowDirection: 'ltr'\n};\nTreeNode.propTypes = {\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  swapFrom: PropTypes.number,\n  swapDepth: PropTypes.number,\n  swapLength: PropTypes.number,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  lowerSiblingCounts: PropTypes.arrayOf(PropTypes.number).isRequired,\n  listIndex: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  // used in dndManager\n  getPrevRow: PropTypes.func.isRequired,\n  node: PropTypes.shape({}).isRequired,\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nfunction _createSuper$2(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar TreePlaceholder =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TreePlaceholder, _Component);\n\n  var _super = _createSuper$2(TreePlaceholder);\n\n  function TreePlaceholder() {\n    _classCallCheck(this, TreePlaceholder);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TreePlaceholder, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          connectDropTarget = _this$props.connectDropTarget,\n          treeId = _this$props.treeId,\n          drop = _this$props.drop,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"connectDropTarget\", \"treeId\", \"drop\"]);\n\n      return connectDropTarget(React.createElement(\"div\", null, Children.map(children, function (child) {\n        return cloneElement(child, _objectSpread2({}, otherProps));\n      })));\n    }\n  }]);\n\n  return TreePlaceholder;\n}(Component);\n\nTreePlaceholder.defaultProps = {\n  canDrop: false,\n  draggedNode: null\n};\nTreePlaceholder.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  treeId: PropTypes.string.isRequired,\n  drop: PropTypes.func.isRequired\n};\n\nfunction defaultGetNodeKey(_ref) {\n  var treeIndex = _ref.treeIndex;\n  return treeIndex;\n} // Cheap hack to get the text of a react object\n\nfunction getReactElementText(parent) {\n  if (typeof parent === 'string') {\n    return parent;\n  }\n\n  if (parent === null || _typeof(parent) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n    return '';\n  }\n\n  if (typeof parent.props.children === 'string') {\n    return parent.props.children;\n  }\n\n  return parent.props.children.map(function (child) {\n    return getReactElementText(child);\n  }).join('');\n} // Search for a query string inside a node property\n\n\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n  if (typeof node[key] === 'function') {\n    // Search within text after calling its function to generate the text\n    return String(node[key]({\n      node: node,\n      path: path,\n      treeIndex: treeIndex\n    })).indexOf(searchQuery) > -1;\n  }\n\n  if (_typeof(node[key]) === 'object') {\n    // Search within text inside react elements\n    return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n  } // Search within string\n\n\n  return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n}\n\nfunction defaultSearchMethod(_ref2) {\n  var node = _ref2.node,\n      path = _ref2.path,\n      treeIndex = _ref2.treeIndex,\n      searchQuery = _ref2.searchQuery;\n  return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n}\n\nvar memoize = function memoize(f) {\n  var savedArgsArray = [];\n  var savedKeysArray = [];\n  var savedResult = null;\n  return function (args) {\n    var keysArray = Object.keys(args).sort();\n    var argsArray = keysArray.map(function (key) {\n      return args[key];\n    }); // If the arguments for the last insert operation are different than this time,\n    // recalculate the result\n\n    if (argsArray.length !== savedArgsArray.length || argsArray.some(function (arg, index) {\n      return arg !== savedArgsArray[index];\n    }) || keysArray.some(function (key, index) {\n      return key !== savedKeysArray[index];\n    })) {\n      savedArgsArray = argsArray;\n      savedKeysArray = keysArray;\n      savedResult = f(args);\n    }\n\n    return savedResult;\n  };\n};\n\nvar memoizedInsertNode = memoize(insertNode);\nvar memoizedGetFlatDataFromTree = memoize(getFlatDataFromTree);\nvar memoizedGetDescendantCount = memoize(getDescendantCount);\n\nvar DndManager =\n/*#__PURE__*/\nfunction () {\n  function DndManager(treeRef) {\n    _classCallCheck(this, DndManager);\n\n    this.treeRef = treeRef;\n  }\n\n  _createClass(DndManager, [{\n    key: \"getTargetDepth\",\n    value: function getTargetDepth(dropTargetProps, monitor, component) {\n      var dropTargetDepth = 0;\n      var rowAbove = dropTargetProps.getPrevRow();\n\n      if (rowAbove) {\n        var path = rowAbove.path;\n        var aboveNodeCannotHaveChildren = !this.treeRef.canNodeHaveChildren(rowAbove.node);\n\n        if (aboveNodeCannotHaveChildren) {\n          path = path.slice(0, path.length - 1);\n        } // Limit the length of the path to the deepest possible\n\n\n        dropTargetDepth = Math.min(path.length, dropTargetProps.path.length);\n      }\n\n      var blocksOffset;\n      var dragSourceInitialDepth = (monitor.getItem().path || []).length; // When adding node from external source\n\n      if (monitor.getItem().treeId !== this.treeId) {\n        // Ignore the tree depth of the source, if it had any to begin with\n        dragSourceInitialDepth = 0;\n\n        if (component) {\n          var relativePosition = findDOMNode(component).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node\n\n          var leftShift = monitor.getSourceClientOffset().x - relativePosition.left;\n          blocksOffset = Math.round(leftShift / dropTargetProps.scaffoldBlockPxWidth);\n        } else {\n          blocksOffset = dropTargetProps.path.length;\n        }\n      } else {\n        // handle row direction support\n        var direction = dropTargetProps.rowDirection === 'rtl' ? -1 : 1;\n        blocksOffset = Math.round(direction * monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n      }\n\n      var targetDepth = Math.min(dropTargetDepth, Math.max(0, dragSourceInitialDepth + blocksOffset - 1)); // If a maxDepth is defined, constrain the target depth\n\n      if (typeof this.maxDepth !== 'undefined' && this.maxDepth !== null) {\n        var draggedNode = monitor.getItem().node;\n        var draggedChildDepth = getDepth(draggedNode);\n        targetDepth = Math.max(0, Math.min(targetDepth, this.maxDepth - draggedChildDepth - 1));\n      }\n\n      return targetDepth;\n    }\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dropTargetProps, monitor) {\n      if (!monitor.isOver()) {\n        return false;\n      }\n\n      var rowAbove = dropTargetProps.getPrevRow();\n      var abovePath = rowAbove ? rowAbove.path : [];\n      var aboveNode = rowAbove ? rowAbove.node : {};\n      var targetDepth = this.getTargetDepth(dropTargetProps, monitor, null); // Cannot drop if we're adding to the children of the row above and\n      //  the row above is a function\n\n      if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\n        return false;\n      }\n\n      if (typeof this.customCanDrop === 'function') {\n        var _monitor$getItem = monitor.getItem(),\n            node = _monitor$getItem.node;\n\n        var addedResult = memoizedInsertNode({\n          treeData: this.treeData,\n          newNode: node,\n          depth: targetDepth,\n          getNodeKey: this.getNodeKey,\n          minimumTreeIndex: dropTargetProps.listIndex,\n          expandParent: true\n        });\n        return this.customCanDrop({\n          node: node,\n          prevPath: monitor.getItem().path,\n          prevParent: monitor.getItem().parentNode,\n          prevTreeIndex: monitor.getItem().treeIndex,\n          // Equals -1 when dragged from external tree\n          nextPath: addedResult.path,\n          nextParent: addedResult.parentNode,\n          nextTreeIndex: addedResult.treeIndex\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"wrapSource\",\n    value: function wrapSource(el) {\n      var _this = this;\n\n      var nodeDragSource = {\n        beginDrag: function beginDrag(props) {\n          _this.startDrag(props);\n\n          return {\n            node: props.node,\n            parentNode: props.parentNode,\n            path: props.path,\n            treeIndex: props.treeIndex,\n            treeId: props.treeId\n          };\n        },\n        endDrag: function endDrag(props, monitor) {\n          _this.endDrag(monitor.getDropResult());\n        },\n        isDragging: function isDragging(props, monitor) {\n          var dropTargetNode = monitor.getItem().node;\n          var draggedNode = props.node;\n          return draggedNode === dropTargetNode;\n        }\n      };\n\n      function nodeDragSourcePropInjection(connect, monitor) {\n        return {\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n          didDrop: monitor.didDrop()\n        };\n      }\n\n      return DragSource(this.dndType, nodeDragSource, nodeDragSourcePropInjection)(el);\n    }\n  }, {\n    key: \"wrapTarget\",\n    value: function wrapTarget(el) {\n      var _this2 = this;\n\n      var nodeDropTarget = {\n        drop: function drop(dropTargetProps, monitor, component) {\n          var result = {\n            node: monitor.getItem().node,\n            path: monitor.getItem().path,\n            treeIndex: monitor.getItem().treeIndex,\n            treeId: _this2.treeId,\n            minimumTreeIndex: dropTargetProps.treeIndex,\n            depth: _this2.getTargetDepth(dropTargetProps, monitor, component)\n          };\n\n          _this2.drop(result);\n\n          return result;\n        },\n        hover: function hover(dropTargetProps, monitor, component) {\n          var targetDepth = _this2.getTargetDepth(dropTargetProps, monitor, component);\n\n          var draggedNode = monitor.getItem().node;\n          var needsRedraw = // Redraw if hovered above different nodes\n          dropTargetProps.node !== draggedNode || // Or hovered above the same node but at a different depth\n          targetDepth !== dropTargetProps.path.length - 1;\n\n          if (!needsRedraw) {\n            return;\n          } // throttle `dragHover` work to available animation frames\n\n\n          cancelAnimationFrame(_this2.rafId);\n          _this2.rafId = requestAnimationFrame(function () {\n            _this2.dragHover({\n              node: draggedNode,\n              path: monitor.getItem().path,\n              minimumTreeIndex: dropTargetProps.listIndex,\n              depth: targetDepth\n            });\n          });\n        },\n        canDrop: this.canDrop.bind(this)\n      };\n\n      function nodeDropTargetPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, nodeDropTarget, nodeDropTargetPropInjection)(el);\n    }\n  }, {\n    key: \"wrapPlaceholder\",\n    value: function wrapPlaceholder(el) {\n      var _this3 = this;\n\n      var placeholderDropTarget = {\n        drop: function drop(dropTargetProps, monitor) {\n          var _monitor$getItem2 = monitor.getItem(),\n              node = _monitor$getItem2.node,\n              path = _monitor$getItem2.path,\n              treeIndex = _monitor$getItem2.treeIndex;\n\n          var result = {\n            node: node,\n            path: path,\n            treeIndex: treeIndex,\n            treeId: _this3.treeId,\n            minimumTreeIndex: 0,\n            depth: 0\n          };\n\n          _this3.drop(result);\n\n          return result;\n        }\n      };\n\n      function placeholderPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, placeholderDropTarget, placeholderPropInjection)(el);\n    }\n  }, {\n    key: \"startDrag\",\n    get: function get() {\n      return this.treeRef.startDrag;\n    }\n  }, {\n    key: \"dragHover\",\n    get: function get() {\n      return this.treeRef.dragHover;\n    }\n  }, {\n    key: \"endDrag\",\n    get: function get() {\n      return this.treeRef.endDrag;\n    }\n  }, {\n    key: \"drop\",\n    get: function get() {\n      return this.treeRef.drop;\n    }\n  }, {\n    key: \"treeId\",\n    get: function get() {\n      return this.treeRef.treeId;\n    }\n  }, {\n    key: \"dndType\",\n    get: function get() {\n      return this.treeRef.dndType;\n    }\n  }, {\n    key: \"treeData\",\n    get: function get() {\n      return this.treeRef.state.draggingTreeData || this.treeRef.props.treeData;\n    }\n  }, {\n    key: \"getNodeKey\",\n    get: function get() {\n      return this.treeRef.props.getNodeKey;\n    }\n  }, {\n    key: \"customCanDrop\",\n    get: function get() {\n      return this.treeRef.props.canDrop;\n    }\n  }, {\n    key: \"maxDepth\",\n    get: function get() {\n      return this.treeRef.props.maxDepth;\n    }\n  }]);\n\n  return DndManager;\n}();\n\n/* eslint-disable import/prefer-default-export */\nfunction slideRows(rows, fromIndex, toIndex) {\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var rowsWithoutMoved = [].concat(_toConsumableArray(rows.slice(0, fromIndex)), _toConsumableArray(rows.slice(fromIndex + count)));\n  return [].concat(_toConsumableArray(rowsWithoutMoved.slice(0, toIndex)), _toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n}\n\nfunction _createSuper$3(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\nvar treeIdCounter = 1;\n\nvar mergeTheme = function mergeTheme(props) {\n  var merged = _objectSpread2(_objectSpread2({}, props), {}, {\n    style: _objectSpread2(_objectSpread2({}, props.theme.style), props.style),\n    innerStyle: _objectSpread2(_objectSpread2({}, props.theme.innerStyle), props.innerStyle),\n    reactVirtualizedListProps: _objectSpread2(_objectSpread2({}, props.theme.reactVirtualizedListProps), props.reactVirtualizedListProps)\n  });\n\n  var overridableDefaults = {\n    nodeContentRenderer: NodeRendererDefault,\n    placeholderRenderer: PlaceholderRendererDefault,\n    rowHeight: 62,\n    scaffoldBlockPxWidth: 44,\n    slideRegionSize: 100,\n    treeNodeRenderer: TreeNode\n  };\n  Object.keys(overridableDefaults).forEach(function (propKey) {\n    // If prop has been specified, do not change it\n    // If prop is specified in theme, use the theme setting\n    // If all else fails, fall back to the default\n    if (props[propKey] === null) {\n      merged[propKey] = typeof props.theme[propKey] !== 'undefined' ? props.theme[propKey] : overridableDefaults[propKey];\n    }\n  });\n  return merged;\n};\n\nvar ReactSortableTree =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ReactSortableTree, _Component);\n\n  var _super = _createSuper$3(ReactSortableTree);\n\n  function ReactSortableTree(props) {\n    var _this;\n\n    _classCallCheck(this, ReactSortableTree);\n\n    _this = _super.call(this, props);\n\n    var _mergeTheme = mergeTheme(props),\n        dndType = _mergeTheme.dndType,\n        nodeContentRenderer = _mergeTheme.nodeContentRenderer,\n        treeNodeRenderer = _mergeTheme.treeNodeRenderer,\n        isVirtualized = _mergeTheme.isVirtualized,\n        slideRegionSize = _mergeTheme.slideRegionSize;\n\n    _this.dndManager = new DndManager(_assertThisInitialized(_this)); // Wrapping classes for use with react-dnd\n\n    _this.treeId = \"rst__\".concat(treeIdCounter);\n    treeIdCounter += 1;\n    _this.dndType = dndType || _this.treeId;\n    _this.nodeContentRenderer = _this.dndManager.wrapSource(nodeContentRenderer);\n    _this.treePlaceholderRenderer = _this.dndManager.wrapPlaceholder(TreePlaceholder);\n    _this.treeNodeRenderer = _this.dndManager.wrapTarget(treeNodeRenderer); // Prepare scroll-on-drag options for this list\n\n    if (isVirtualized) {\n      _this.scrollZoneVirtualList = (createScrollingComponent || withScrolling)(List);\n      _this.vStrength = createVerticalStrength(slideRegionSize);\n      _this.hStrength = createHorizontalStrength(slideRegionSize);\n    }\n\n    _this.state = {\n      draggingTreeData: null,\n      draggedNode: null,\n      draggedMinimumTreeIndex: null,\n      draggedDepth: null,\n      searchMatches: [],\n      searchFocusTreeIndex: null,\n      dragging: false,\n      // props that need to be used in gDSFP or static functions will be stored here\n      instanceProps: {\n        treeData: [],\n        ignoreOneTreeUpdate: false,\n        searchQuery: null,\n        searchFocusOffset: null\n      }\n    };\n    _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_assertThisInitialized(_this));\n    _this.moveNode = _this.moveNode.bind(_assertThisInitialized(_this));\n    _this.startDrag = _this.startDrag.bind(_assertThisInitialized(_this));\n    _this.dragHover = _this.dragHover.bind(_assertThisInitialized(_this));\n    _this.endDrag = _this.endDrag.bind(_assertThisInitialized(_this));\n    _this.drop = _this.drop.bind(_assertThisInitialized(_this));\n    _this.handleDndMonitorChange = _this.handleDndMonitorChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ReactSortableTree, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      ReactSortableTree.loadLazyChildren(this.props, this.state);\n      var stateUpdate = ReactSortableTree.search(this.props, this.state, true, true, false);\n      this.setState(stateUpdate); // Hook into react-dnd state changes to detect when the drag ends\n      // TODO: This is very brittle, so it needs to be replaced if react-dnd\n      // offers a more official way to detect when a drag ends\n\n      this.clearMonitorSubscription = this.props.dragDropManager.getMonitor().subscribeToStateChange(this.handleDndMonitorChange);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    // listen to dragging\n    value: function componentDidUpdate(prevProps, prevState) {\n      // if it is not the same then call the onDragStateChanged\n      if (this.state.dragging !== prevState.dragging) {\n        if (this.props.onDragStateChanged) {\n          this.props.onDragStateChanged({\n            isDragging: this.state.dragging,\n            draggedNode: this.state.draggedNode\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearMonitorSubscription();\n    }\n  }, {\n    key: \"getRows\",\n    value: function getRows(treeData) {\n      return memoizedGetFlatDataFromTree({\n        ignoreCollapsed: true,\n        getNodeKey: this.props.getNodeKey,\n        treeData: treeData\n      });\n    }\n  }, {\n    key: \"handleDndMonitorChange\",\n    value: function handleDndMonitorChange() {\n      var monitor = this.props.dragDropManager.getMonitor(); // If the drag ends and the tree is still in a mid-drag state,\n      // it means that the drag was canceled or the dragSource dropped\n      // elsewhere, and we should reset the state of this tree\n\n      if (!monitor.isDragging() && this.state.draggingTreeData) {\n        this.endDrag();\n      }\n    }\n  }, {\n    key: \"toggleChildrenVisibility\",\n    value: function toggleChildrenVisibility(_ref) {\n      var targetNode = _ref.node,\n          path = _ref.path;\n      var instanceProps = this.state.instanceProps;\n      var treeData = changeNodeAtPath({\n        treeData: instanceProps.treeData,\n        path: path,\n        newNode: function newNode(_ref2) {\n          var node = _ref2.node;\n          return _objectSpread2(_objectSpread2({}, node), {}, {\n            expanded: !node.expanded\n          });\n        },\n        getNodeKey: this.props.getNodeKey\n      });\n      this.props.onChange(treeData);\n      this.props.onVisibilityToggle({\n        treeData: treeData,\n        node: targetNode,\n        expanded: !targetNode.expanded,\n        path: path\n      });\n    }\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(_ref3) {\n      var node = _ref3.node,\n          prevPath = _ref3.path,\n          prevTreeIndex = _ref3.treeIndex,\n          depth = _ref3.depth,\n          minimumTreeIndex = _ref3.minimumTreeIndex;\n\n      var _insertNode = insertNode({\n        treeData: this.state.draggingTreeData,\n        newNode: node,\n        depth: depth,\n        minimumTreeIndex: minimumTreeIndex,\n        expandParent: true,\n        getNodeKey: this.props.getNodeKey\n      }),\n          treeData = _insertNode.treeData,\n          treeIndex = _insertNode.treeIndex,\n          path = _insertNode.path,\n          nextParentNode = _insertNode.parentNode;\n\n      this.props.onChange(treeData);\n      this.props.onMoveNode({\n        treeData: treeData,\n        node: node,\n        treeIndex: treeIndex,\n        path: path,\n        nextPath: path,\n        nextTreeIndex: treeIndex,\n        prevPath: prevPath,\n        prevTreeIndex: prevTreeIndex,\n        nextParentNode: nextParentNode\n      });\n    } // returns the new state after search\n\n  }, {\n    key: \"startDrag\",\n    value: function startDrag(_ref4) {\n      var _this2 = this;\n\n      var path = _ref4.path;\n      this.setState(function (prevState) {\n        var _removeNode = removeNode({\n          treeData: prevState.instanceProps.treeData,\n          path: path,\n          getNodeKey: _this2.props.getNodeKey\n        }),\n            draggingTreeData = _removeNode.treeData,\n            draggedNode = _removeNode.node,\n            draggedMinimumTreeIndex = _removeNode.treeIndex;\n\n        return {\n          draggingTreeData: draggingTreeData,\n          draggedNode: draggedNode,\n          draggedDepth: path.length - 1,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"dragHover\",\n    value: function dragHover(_ref5) {\n      var _this3 = this;\n\n      var draggedNode = _ref5.node,\n          draggedDepth = _ref5.depth,\n          draggedMinimumTreeIndex = _ref5.minimumTreeIndex;\n\n      // Ignore this hover if it is at the same position as the last hover\n      if (this.state.draggedDepth === draggedDepth && this.state.draggedMinimumTreeIndex === draggedMinimumTreeIndex) {\n        return;\n      }\n\n      this.setState(function (_ref6) {\n        var draggingTreeData = _ref6.draggingTreeData,\n            instanceProps = _ref6.instanceProps;\n        // Fall back to the tree data if something is being dragged in from\n        //  an external element\n        var newDraggingTreeData = draggingTreeData || instanceProps.treeData;\n        var addedResult = memoizedInsertNode({\n          treeData: newDraggingTreeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: _this3.props.getNodeKey\n        });\n\n        var rows = _this3.getRows(addedResult.treeData);\n\n        var expandedParentPath = rows[addedResult.treeIndex].path;\n        return {\n          draggedNode: draggedNode,\n          draggedDepth: draggedDepth,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          draggingTreeData: changeNodeAtPath({\n            treeData: newDraggingTreeData,\n            path: expandedParentPath.slice(0, -1),\n            newNode: function newNode(_ref7) {\n              var node = _ref7.node;\n              return _objectSpread2(_objectSpread2({}, node), {}, {\n                expanded: true\n              });\n            },\n            getNodeKey: _this3.props.getNodeKey\n          }),\n          // reset the scroll focus so it doesn't jump back\n          // to a search result while dragging\n          searchFocusTreeIndex: null,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"endDrag\",\n    value: function endDrag(dropResult) {\n      var _this4 = this;\n\n      var instanceProps = this.state.instanceProps;\n\n      var resetTree = function resetTree() {\n        return _this4.setState({\n          draggingTreeData: null,\n          draggedNode: null,\n          draggedMinimumTreeIndex: null,\n          draggedDepth: null,\n          dragging: false\n        });\n      }; // Drop was cancelled\n\n\n      if (!dropResult) {\n        resetTree();\n      } else if (dropResult.treeId !== this.treeId) {\n        // The node was dropped in an external drop target or tree\n        var node = dropResult.node,\n            path = dropResult.path,\n            treeIndex = dropResult.treeIndex;\n        var shouldCopy = this.props.shouldCopyOnOutsideDrop;\n\n        if (typeof shouldCopy === 'function') {\n          shouldCopy = shouldCopy({\n            node: node,\n            prevTreeIndex: treeIndex,\n            prevPath: path\n          });\n        }\n\n        var treeData = this.state.draggingTreeData || instanceProps.treeData; // If copying is enabled, a drop outside leaves behind a copy in the\n        //  source tree\n\n        if (shouldCopy) {\n          treeData = changeNodeAtPath({\n            treeData: instanceProps.treeData,\n            // use treeData unaltered by the drag operation\n            path: path,\n            newNode: function newNode(_ref8) {\n              var copyNode = _ref8.node;\n              return _objectSpread2({}, copyNode);\n            },\n            // create a shallow copy of the node\n            getNodeKey: this.props.getNodeKey\n          });\n        }\n\n        this.props.onChange(treeData);\n        this.props.onMoveNode({\n          treeData: treeData,\n          node: node,\n          treeIndex: null,\n          path: null,\n          nextPath: null,\n          nextTreeIndex: null,\n          prevPath: path,\n          prevTreeIndex: treeIndex\n        });\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(dropResult) {\n      this.moveNode(dropResult);\n    }\n  }, {\n    key: \"canNodeHaveChildren\",\n    value: function canNodeHaveChildren(node) {\n      var canNodeHaveChildren = this.props.canNodeHaveChildren;\n\n      if (canNodeHaveChildren) {\n        return canNodeHaveChildren(node);\n      }\n\n      return true;\n    } // Load any children in the tree that are given by a function\n    // calls the onChange callback on the new treeData\n\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(row, _ref9) {\n      var listIndex = _ref9.listIndex,\n          style = _ref9.style,\n          getPrevRow = _ref9.getPrevRow,\n          matchKeys = _ref9.matchKeys,\n          swapFrom = _ref9.swapFrom,\n          swapDepth = _ref9.swapDepth,\n          swapLength = _ref9.swapLength;\n      var node = row.node,\n          parentNode = row.parentNode,\n          path = row.path,\n          lowerSiblingCounts = row.lowerSiblingCounts,\n          treeIndex = row.treeIndex;\n\n      var _mergeTheme2 = mergeTheme(this.props),\n          canDrag = _mergeTheme2.canDrag,\n          generateNodeProps = _mergeTheme2.generateNodeProps,\n          scaffoldBlockPxWidth = _mergeTheme2.scaffoldBlockPxWidth,\n          searchFocusOffset = _mergeTheme2.searchFocusOffset,\n          rowDirection = _mergeTheme2.rowDirection;\n\n      var TreeNodeRenderer = this.treeNodeRenderer;\n      var NodeContentRenderer = this.nodeContentRenderer;\n      var nodeKey = path[path.length - 1];\n      var isSearchMatch = nodeKey in matchKeys;\n      var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\n      var callbackParams = {\n        node: node,\n        parentNode: parentNode,\n        path: path,\n        lowerSiblingCounts: lowerSiblingCounts,\n        treeIndex: treeIndex,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus\n      };\n      var nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\n      var rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\n      var sharedProps = {\n        treeIndex: treeIndex,\n        scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n        node: node,\n        path: path,\n        treeId: this.treeId,\n        rowDirection: rowDirection\n      };\n      return React.createElement(TreeNodeRenderer, _extends({\n        style: style,\n        key: nodeKey,\n        listIndex: listIndex,\n        getPrevRow: getPrevRow,\n        lowerSiblingCounts: lowerSiblingCounts,\n        swapFrom: swapFrom,\n        swapLength: swapLength,\n        swapDepth: swapDepth\n      }, sharedProps), React.createElement(NodeContentRenderer, _extends({\n        parentNode: parentNode,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus,\n        canDrag: rowCanDrag,\n        toggleChildrenVisibility: this.toggleChildrenVisibility\n      }, sharedProps, nodeProps)));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _mergeTheme3 = mergeTheme(this.props),\n          dragDropManager = _mergeTheme3.dragDropManager,\n          style = _mergeTheme3.style,\n          className = _mergeTheme3.className,\n          innerStyle = _mergeTheme3.innerStyle,\n          rowHeight = _mergeTheme3.rowHeight,\n          isVirtualized = _mergeTheme3.isVirtualized,\n          placeholderRenderer = _mergeTheme3.placeholderRenderer,\n          reactVirtualizedListProps = _mergeTheme3.reactVirtualizedListProps,\n          getNodeKey = _mergeTheme3.getNodeKey,\n          rowDirection = _mergeTheme3.rowDirection;\n\n      var _this$state = this.state,\n          searchMatches = _this$state.searchMatches,\n          searchFocusTreeIndex = _this$state.searchFocusTreeIndex,\n          draggedNode = _this$state.draggedNode,\n          draggedDepth = _this$state.draggedDepth,\n          draggedMinimumTreeIndex = _this$state.draggedMinimumTreeIndex,\n          instanceProps = _this$state.instanceProps;\n      var treeData = this.state.draggingTreeData || instanceProps.treeData;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var rows;\n      var swapFrom = null;\n      var swapLength = null;\n\n      if (draggedNode && draggedMinimumTreeIndex !== null) {\n        var addedResult = memoizedInsertNode({\n          treeData: treeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: getNodeKey\n        });\n        var swapTo = draggedMinimumTreeIndex;\n        swapFrom = addedResult.treeIndex;\n        swapLength = 1 + memoizedGetDescendantCount({\n          node: draggedNode\n        });\n        rows = slideRows(this.getRows(addedResult.treeData), swapFrom, swapTo, swapLength);\n      } else {\n        rows = this.getRows(treeData);\n      } // Get indices for rows that match the search conditions\n\n\n      var matchKeys = {};\n      searchMatches.forEach(function (_ref10, i) {\n        var path = _ref10.path;\n        matchKeys[path[path.length - 1]] = i;\n      }); // Seek to the focused search result if there is one specified\n\n      var scrollToInfo = searchFocusTreeIndex !== null ? {\n        scrollToIndex: searchFocusTreeIndex\n      } : {};\n      var containerStyle = style;\n      var list;\n\n      if (rows.length < 1) {\n        var Placeholder = this.treePlaceholderRenderer;\n        var PlaceholderContent = placeholderRenderer;\n        list = React.createElement(Placeholder, {\n          treeId: this.treeId,\n          drop: this.drop\n        }, React.createElement(PlaceholderContent, null));\n      } else if (isVirtualized) {\n        containerStyle = _objectSpread2({\n          height: '100%'\n        }, containerStyle);\n        var ScrollZoneVirtualList = this.scrollZoneVirtualList; // Render list with react-virtualized\n\n        list = React.createElement(AutoSizer, null, function (_ref11) {\n          var height = _ref11.height,\n              width = _ref11.width;\n          return React.createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {\n            dragDropManager: dragDropManager,\n            verticalStrength: _this5.vStrength,\n            horizontalStrength: _this5.hStrength,\n            speed: 30,\n            scrollToAlignment: \"start\",\n            className: \"rst__virtualScrollOverride\",\n            width: width,\n            onScroll: function onScroll(_ref12) {\n              var scrollTop = _ref12.scrollTop;\n              _this5.scrollTop = scrollTop;\n            },\n            height: height,\n            style: innerStyle,\n            rowCount: rows.length,\n            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,\n            rowHeight: typeof rowHeight !== 'function' ? rowHeight : function (_ref13) {\n              var index = _ref13.index;\n              return rowHeight({\n                index: index,\n                treeIndex: index,\n                node: rows[index].node,\n                path: rows[index].path\n              });\n            },\n            rowRenderer: function rowRenderer(_ref14) {\n              var index = _ref14.index,\n                  rowStyle = _ref14.style;\n              return _this5.renderRow(rows[index], {\n                listIndex: index,\n                style: rowStyle,\n                getPrevRow: function getPrevRow() {\n                  return rows[index - 1] || null;\n                },\n                matchKeys: matchKeys,\n                swapFrom: swapFrom,\n                swapDepth: draggedDepth,\n                swapLength: swapLength\n              });\n            }\n          }, reactVirtualizedListProps));\n        });\n      } else {\n        // Render list without react-virtualized\n        list = rows.map(function (row, index) {\n          return _this5.renderRow(row, {\n            listIndex: index,\n            style: {\n              height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({\n                index: index,\n                treeIndex: index,\n                node: row.node,\n                path: row.path\n              })\n            },\n            getPrevRow: function getPrevRow() {\n              return rows[index - 1] || null;\n            },\n            matchKeys: matchKeys,\n            swapFrom: swapFrom,\n            swapDepth: draggedDepth,\n            swapLength: swapLength\n          });\n        });\n      }\n\n      return React.createElement(\"div\", {\n        className: classnames('rst__tree', className, rowDirectionClass),\n        style: containerStyle\n      }, list);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var instanceProps = prevState.instanceProps;\n      var newState = {};\n      var isTreeDataEqual = isEqual(instanceProps.treeData, nextProps.treeData); // make sure we have the most recent version of treeData\n\n      instanceProps.treeData = nextProps.treeData;\n\n      if (!isTreeDataEqual) {\n        if (instanceProps.ignoreOneTreeUpdate) {\n          instanceProps.ignoreOneTreeUpdate = false;\n        } else {\n          newState.searchFocusTreeIndex = null;\n          ReactSortableTree.loadLazyChildren(nextProps, prevState);\n          Object.assign(newState, ReactSortableTree.search(nextProps, prevState, false, false, false));\n        }\n\n        newState.draggingTreeData = null;\n        newState.draggedNode = null;\n        newState.draggedMinimumTreeIndex = null;\n        newState.draggedDepth = null;\n        newState.dragging = false;\n      } else if (!isEqual(instanceProps.searchQuery, nextProps.searchQuery)) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, false));\n      } else if (instanceProps.searchFocusOffset !== nextProps.searchFocusOffset) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, true));\n      }\n\n      instanceProps.searchQuery = nextProps.searchQuery;\n      instanceProps.searchFocusOffset = nextProps.searchFocusOffset;\n      newState.instanceProps = _objectSpread2(_objectSpread2({}, instanceProps), newState.instanceProps);\n      return newState;\n    }\n  }, {\n    key: \"search\",\n    value: function search(props, state, seekIndex, expand, singleSearch) {\n      var onChange = props.onChange,\n          getNodeKey = props.getNodeKey,\n          searchFinishCallback = props.searchFinishCallback,\n          searchQuery = props.searchQuery,\n          searchMethod = props.searchMethod,\n          searchFocusOffset = props.searchFocusOffset,\n          onlyExpandSearchedNodes = props.onlyExpandSearchedNodes;\n      var instanceProps = state.instanceProps; // Skip search if no conditions are specified\n\n      if (!searchQuery && !searchMethod) {\n        if (searchFinishCallback) {\n          searchFinishCallback([]);\n        }\n\n        return {\n          searchMatches: []\n        };\n      }\n\n      var newState = {\n        instanceProps: {}\n      }; // if onlyExpandSearchedNodes collapse the tree and search\n\n      var _find = find({\n        getNodeKey: getNodeKey,\n        treeData: onlyExpandSearchedNodes ? toggleExpandedForAll({\n          treeData: instanceProps.treeData,\n          expanded: false\n        }) : instanceProps.treeData,\n        searchQuery: searchQuery,\n        searchMethod: searchMethod || defaultSearchMethod,\n        searchFocusOffset: searchFocusOffset,\n        expandAllMatchPaths: expand && !singleSearch,\n        expandFocusMatchPaths: !!expand\n      }),\n          expandedTreeData = _find.treeData,\n          searchMatches = _find.matches; // Update the tree with data leaving all paths leading to matching nodes open\n\n\n      if (expand) {\n        newState.instanceProps.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\n        onChange(expandedTreeData);\n      }\n\n      if (searchFinishCallback) {\n        searchFinishCallback(searchMatches);\n      }\n\n      var searchFocusTreeIndex = null;\n\n      if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n        searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n      }\n\n      newState.searchMatches = searchMatches;\n      newState.searchFocusTreeIndex = searchFocusTreeIndex;\n      return newState;\n    }\n  }, {\n    key: \"loadLazyChildren\",\n    value: function loadLazyChildren(props, state) {\n      var instanceProps = state.instanceProps;\n      walk({\n        treeData: instanceProps.treeData,\n        getNodeKey: props.getNodeKey,\n        callback: function callback(_ref15) {\n          var node = _ref15.node,\n              path = _ref15.path,\n              lowerSiblingCounts = _ref15.lowerSiblingCounts,\n              treeIndex = _ref15.treeIndex;\n\n          // If the node has children defined by a function, and is either expanded\n          //  or set to load even before expansion, run the function.\n          if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n            // Call the children fetching function\n            node.children({\n              node: node,\n              path: path,\n              lowerSiblingCounts: lowerSiblingCounts,\n              treeIndex: treeIndex,\n              // Provide a helper to append the new data when it is received\n              done: function done(childrenArray) {\n                return props.onChange(changeNodeAtPath({\n                  treeData: instanceProps.treeData,\n                  path: path,\n                  newNode: function newNode(_ref16) {\n                    var oldNode = _ref16.node;\n                    return (// Only replace the old node if it's the one we set off to find children\n                      //  for in the first place\n                      oldNode === node ? _objectSpread2(_objectSpread2({}, oldNode), {}, {\n                        children: childrenArray\n                      }) : oldNode\n                    );\n                  },\n                  getNodeKey: props.getNodeKey\n                }));\n              }\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReactSortableTree;\n}(Component);\n\nReactSortableTree.propTypes = {\n  dragDropManager: PropTypes.shape({\n    getMonitor: PropTypes.func\n  }).isRequired,\n  // Tree data in the following format:\n  // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n  // `title` is the primary label for the node\n  // `subtitle` is a secondary label for the node\n  // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n  // `children` is an array of child nodes belonging to the node.\n  treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\n  // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n  style: PropTypes.shape({}),\n  // Class name for the container wrapping the tree\n  className: PropTypes.string,\n  // Style applied to the inner, scrollable container (for padding, etc.)\n  innerStyle: PropTypes.shape({}),\n  // Used by react-virtualized\n  // Either a fixed row height (number) or a function that returns the\n  // height of a row given its index: `({ index: number }): number`\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  // Size in px of the region near the edges that initiates scrolling on dragover\n  slideRegionSize: PropTypes.number,\n  // Custom properties to hand to the react-virtualized list\n  // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n  reactVirtualizedListProps: PropTypes.shape({}),\n  // The width of the blocks containing the lines representing the structure of the tree.\n  scaffoldBlockPxWidth: PropTypes.number,\n  // Maximum depth nodes can be inserted at. Defaults to infinite.\n  maxDepth: PropTypes.number,\n  // The method used to search nodes.\n  // Defaults to a function that uses the `searchQuery` string to search for nodes with\n  // matching `title` or `subtitle` values.\n  // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n  searchMethod: PropTypes.func,\n  // Used by the `searchMethod` to highlight and scroll to matched nodes.\n  // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n  searchQuery: PropTypes.any,\n  // eslint-disable-line react/forbid-prop-types\n  // Outline the <`searchFocusOffset`>th node and scroll to it.\n  searchFocusOffset: PropTypes.number,\n  // Get the nodes that match the search criteria. Used for counting total matches, etc.\n  searchFinishCallback: PropTypes.func,\n  // Generate an object with additional props to be passed to the node renderer.\n  // Use this for adding buttons via the `buttons` key,\n  // or additional `style` / `className` settings.\n  generateNodeProps: PropTypes.func,\n  // Set to false to disable virtualization.\n  // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\n  isVirtualized: PropTypes.bool,\n  treeNodeRenderer: PropTypes.func,\n  // Override the default component for rendering nodes (but keep the scaffolding generator)\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n  nodeContentRenderer: PropTypes.func,\n  // Override the default component for rendering an empty tree\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `placeholder-renderer-default.js` to use as a base,\n  // and customize as needed.\n  placeholderRenderer: PropTypes.func,\n  theme: PropTypes.shape({\n    style: PropTypes.shape({}),\n    innerStyle: PropTypes.shape({}),\n    reactVirtualizedListProps: PropTypes.shape({}),\n    scaffoldBlockPxWidth: PropTypes.number,\n    slideRegionSize: PropTypes.number,\n    rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    treeNodeRenderer: PropTypes.func,\n    nodeContentRenderer: PropTypes.func,\n    placeholderRenderer: PropTypes.func\n  }),\n  // Determine the unique key used to identify each node and\n  // generate the `path` array passed in callbacks.\n  // By default, returns the index in the tree (omitting hidden nodes).\n  getNodeKey: PropTypes.func,\n  // Called whenever tree data changed.\n  // Just like with React input elements, you have to update your\n  // own component's data to see the changes reflected.\n  onChange: PropTypes.func.isRequired,\n  // Called after node move operation.\n  onMoveNode: PropTypes.func,\n  // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\n  canDrag: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Determine whether a node can be dropped based on its path and parents'.\n  canDrop: PropTypes.func,\n  // Determine whether a node can have children\n  canNodeHaveChildren: PropTypes.func,\n  // When true, or a callback returning true, dropping nodes to react-dnd\n  // drop targets outside of this tree will not remove them from this tree\n  shouldCopyOnOutsideDrop: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Called after children nodes collapsed or expanded.\n  onVisibilityToggle: PropTypes.func,\n  dndType: PropTypes.string,\n  // Called to track between dropped and dragging\n  onDragStateChanged: PropTypes.func,\n  // Specify that nodes that do not match search will be collapsed\n  onlyExpandSearchedNodes: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\nReactSortableTree.defaultProps = {\n  canDrag: true,\n  canDrop: null,\n  canNodeHaveChildren: function canNodeHaveChildren() {\n    return true;\n  },\n  className: '',\n  dndType: null,\n  generateNodeProps: null,\n  getNodeKey: defaultGetNodeKey,\n  innerStyle: {},\n  isVirtualized: true,\n  maxDepth: null,\n  treeNodeRenderer: null,\n  nodeContentRenderer: null,\n  onMoveNode: function onMoveNode() {},\n  onVisibilityToggle: function onVisibilityToggle() {},\n  placeholderRenderer: null,\n  reactVirtualizedListProps: {},\n  rowHeight: null,\n  scaffoldBlockPxWidth: null,\n  searchFinishCallback: null,\n  searchFocusOffset: null,\n  searchMethod: null,\n  searchQuery: null,\n  shouldCopyOnOutsideDrop: false,\n  slideRegionSize: null,\n  style: {},\n  theme: {},\n  onDragStateChanged: function onDragStateChanged() {},\n  onlyExpandSearchedNodes: false,\n  rowDirection: 'ltr'\n};\npolyfill(ReactSortableTree);\n\nvar SortableTreeWithoutDndContext = function SortableTreeWithoutDndContext(props) {\n  return React.createElement(DndContext.Consumer, null, function (_ref17) {\n    var dragDropManager = _ref17.dragDropManager;\n    return dragDropManager === undefined ? null : React.createElement(ReactSortableTree, _extends({}, props, {\n      dragDropManager: dragDropManager\n    }));\n  });\n};\n\nvar SortableTree = function SortableTree(props) {\n  return React.createElement(DndProvider, {\n    backend: HTML5Backend\n  }, React.createElement(SortableTreeWithoutDndContext, props));\n}; // Export the tree component without the react-dnd DragDropContext,\n\nexport default SortableTree;\nexport { SortableTreeWithoutDndContext, addNodeUnderParent, changeNodeAtPath, defaultGetNodeKey, defaultSearchMethod, find, getDepth, getDescendantCount, getFlatDataFromTree, getNodeAtPath, getTreeFromFlatData, getVisibleNodeCount, getVisibleNodeInfoAtIndex, insertNode, isDescendant, map, removeNode, removeNodeAtPath, toggleExpandedForAll, walk };\n"]},"metadata":{},"sourceType":"module"}